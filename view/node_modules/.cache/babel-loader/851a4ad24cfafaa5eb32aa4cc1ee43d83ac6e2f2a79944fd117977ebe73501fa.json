{"ast":null,"code":"/**\n * Based on aframe/examples/showcase/tracked-controls.\n *\n * Implement bounding sphere collision detection for entities with a mesh.\n * Sets the specified state on the intersected entities.\n *\n * @property {string} objects - Selector of the entities to test for collision.\n * @property {string} state - State to set on collided entities.\n *\n */\nmodule.exports = AFRAME.registerComponent('sphere-collider', {\n  schema: {\n    enabled: {\n      default: true\n    },\n    interval: {\n      default: 80\n    },\n    objects: {\n      default: ''\n    },\n    state: {\n      default: 'collided'\n    },\n    radius: {\n      default: 0.05\n    },\n    watch: {\n      default: true\n    }\n  },\n  init: function () {\n    /** @type {MutationObserver} */\n    this.observer = null;\n    /** @type {Array<Element>} Elements to watch for collisions. */\n    this.els = [];\n    /** @type {Array<Element>} Elements currently in collision state. */\n    this.collisions = [];\n    this.prevCheckTime = undefined;\n    this.eventDetail = {};\n    this.handleHit = this.handleHit.bind(this);\n    this.handleHitEnd = this.handleHitEnd.bind(this);\n  },\n  play: function () {\n    const sceneEl = this.el.sceneEl;\n    if (this.data.watch) {\n      this.observer = new MutationObserver(this.update.bind(this, null));\n      this.observer.observe(sceneEl, {\n        childList: true,\n        subtree: true\n      });\n    }\n  },\n  pause: function () {\n    if (this.observer) {\n      this.observer.disconnect();\n      this.observer = null;\n    }\n  },\n  /**\n   * Update list of entities to test for collision.\n   */\n  update: function () {\n    const data = this.data;\n    let objectEls;\n\n    // Push entities into list of els to intersect.\n    if (data.objects) {\n      objectEls = this.el.sceneEl.querySelectorAll(data.objects);\n    } else {\n      // If objects not defined, intersect with everything.\n      objectEls = this.el.sceneEl.children;\n    }\n    // Convert from NodeList to Array\n    this.els = Array.prototype.slice.call(objectEls);\n  },\n  tick: function () {\n    const position = new THREE.Vector3(),\n      meshPosition = new THREE.Vector3(),\n      colliderScale = new THREE.Vector3(),\n      size = new THREE.Vector3(),\n      box = new THREE.Box3(),\n      collisions = [],\n      distanceMap = new Map();\n    return function (time) {\n      if (!this.data.enabled) {\n        return;\n      }\n\n      // Only check for intersection if interval time has passed.\n      const prevCheckTime = this.prevCheckTime;\n      if (prevCheckTime && time - prevCheckTime < this.data.interval) {\n        return;\n      }\n      // Update check time.\n      this.prevCheckTime = time;\n      const el = this.el,\n        data = this.data,\n        mesh = el.getObject3D('mesh');\n      let colliderRadius;\n      if (!mesh) {\n        return;\n      }\n      collisions.length = 0;\n      distanceMap.clear();\n      el.object3D.getWorldPosition(position);\n      el.object3D.getWorldScale(colliderScale);\n      colliderRadius = data.radius * scaleFactor(colliderScale);\n      // Update collision list.\n      this.els.forEach(intersect);\n\n      // Emit events and add collision states, in order of distance.\n      collisions.sort((a, b) => distanceMap.get(a) > distanceMap.get(b) ? 1 : -1).forEach(this.handleHit);\n\n      // Remove collision state from other elements.\n      this.collisions.filter(el => !distanceMap.has(el)).forEach(this.handleHitEnd);\n\n      // Store new collisions\n      copyArray(this.collisions, collisions);\n\n      // Bounding sphere collision detection\n      function intersect(el) {\n        let radius, mesh, distance, extent;\n        if (!el.isEntity) {\n          return;\n        }\n        mesh = el.getObject3D('mesh');\n        if (!mesh) {\n          return;\n        }\n        box.setFromObject(mesh).getSize(size);\n        extent = Math.max(size.x, size.y, size.z) / 2;\n        radius = Math.sqrt(2 * extent * extent);\n        box.getCenter(meshPosition);\n        if (!radius) {\n          return;\n        }\n        distance = position.distanceTo(meshPosition);\n        if (distance < radius + colliderRadius) {\n          collisions.push(el);\n          distanceMap.set(el, distance);\n        }\n      }\n      // use max of scale factors to maintain bounding sphere collision\n      function scaleFactor(scaleVec) {\n        return Math.max(scaleVec.x, scaleVec.y, scaleVec.z);\n      }\n    };\n  }(),\n  handleHit: function (targetEl) {\n    targetEl.emit('hit');\n    targetEl.addState(this.data.state);\n    this.eventDetail.el = targetEl;\n    this.el.emit('hit', this.eventDetail);\n  },\n  handleHitEnd: function (targetEl) {\n    targetEl.emit('hitend');\n    targetEl.removeState(this.data.state);\n    this.eventDetail.el = targetEl;\n    this.el.emit('hitend', this.eventDetail);\n  }\n});\nfunction copyArray(dest, source) {\n  dest.length = 0;\n  for (let i = 0; i < source.length; i++) {\n    dest[i] = source[i];\n  }\n}","map":{"version":3,"names":["module","exports","AFRAME","registerComponent","schema","enabled","default","interval","objects","state","radius","watch","init","observer","els","collisions","prevCheckTime","undefined","eventDetail","handleHit","bind","handleHitEnd","play","sceneEl","el","data","MutationObserver","update","observe","childList","subtree","pause","disconnect","objectEls","querySelectorAll","children","Array","prototype","slice","call","tick","position","THREE","Vector3","meshPosition","colliderScale","size","box","Box3","distanceMap","Map","time","mesh","getObject3D","colliderRadius","length","clear","object3D","getWorldPosition","getWorldScale","scaleFactor","forEach","intersect","sort","a","b","get","filter","has","copyArray","distance","extent","isEntity","setFromObject","getSize","Math","max","x","y","z","sqrt","getCenter","distanceTo","push","set","scaleVec","targetEl","emit","addState","removeState","dest","source","i"],"sources":["C:/UsersFolders/Polina/РЭУ/Graph/view/node_modules/aframe-extras/src/misc/sphere-collider.js"],"sourcesContent":["/**\n * Based on aframe/examples/showcase/tracked-controls.\n *\n * Implement bounding sphere collision detection for entities with a mesh.\n * Sets the specified state on the intersected entities.\n *\n * @property {string} objects - Selector of the entities to test for collision.\n * @property {string} state - State to set on collided entities.\n *\n */\nmodule.exports = AFRAME.registerComponent('sphere-collider', {\n  schema: {\n    enabled: {default: true},\n    interval: {default: 80},\n    objects: {default: ''},\n    state: {default: 'collided'},\n    radius: {default: 0.05},\n    watch: {default: true}\n  },\n\n  init: function () {\n    /** @type {MutationObserver} */\n    this.observer = null;\n    /** @type {Array<Element>} Elements to watch for collisions. */\n    this.els = [];\n    /** @type {Array<Element>} Elements currently in collision state. */\n    this.collisions = [];\n    this.prevCheckTime = undefined;\n\n    this.eventDetail = {};\n    this.handleHit = this.handleHit.bind(this);\n    this.handleHitEnd = this.handleHitEnd.bind(this);\n  },\n\n  play: function () {\n    const sceneEl = this.el.sceneEl;\n\n    if (this.data.watch) {\n      this.observer = new MutationObserver(this.update.bind(this, null));\n      this.observer.observe(sceneEl, {childList: true, subtree: true});\n    }\n  },\n\n  pause: function () {\n    if (this.observer) {\n      this.observer.disconnect();\n      this.observer = null;\n    }\n  },\n\n  /**\n   * Update list of entities to test for collision.\n   */\n  update: function () {\n    const data = this.data;\n    let objectEls;\n\n    // Push entities into list of els to intersect.\n    if (data.objects) {\n      objectEls = this.el.sceneEl.querySelectorAll(data.objects);\n    } else {\n      // If objects not defined, intersect with everything.\n      objectEls = this.el.sceneEl.children;\n    }\n    // Convert from NodeList to Array\n    this.els = Array.prototype.slice.call(objectEls);\n  },\n\n  tick: (function () {\n    const position = new THREE.Vector3(),\n        meshPosition = new THREE.Vector3(),\n        colliderScale = new THREE.Vector3(),\n        size = new THREE.Vector3(),\n        box = new THREE.Box3(),\n        collisions = [],\n        distanceMap = new Map();\n    return function (time) {\n      if (!this.data.enabled) { return; }\n\n      // Only check for intersection if interval time has passed.\n      const prevCheckTime = this.prevCheckTime;\n      if (prevCheckTime && (time - prevCheckTime < this.data.interval)) { return; }\n      // Update check time.\n      this.prevCheckTime = time;\n\n      const el = this.el,\n          data = this.data,\n          mesh = el.getObject3D('mesh');\n      let colliderRadius;\n\n      if (!mesh) { return; }\n\n      collisions.length = 0;\n      distanceMap.clear();\n      el.object3D.getWorldPosition(position);\n      el.object3D.getWorldScale(colliderScale);\n      colliderRadius = data.radius * scaleFactor(colliderScale);\n      // Update collision list.\n      this.els.forEach(intersect);\n\n      // Emit events and add collision states, in order of distance.\n      collisions\n        .sort((a, b) => distanceMap.get(a) > distanceMap.get(b) ? 1 : -1)\n        .forEach(this.handleHit);\n\n      // Remove collision state from other elements.\n      this.collisions\n        .filter((el) => !distanceMap.has(el))\n        .forEach(this.handleHitEnd);\n\n      // Store new collisions\n      copyArray(this.collisions, collisions);\n\n      // Bounding sphere collision detection\n      function intersect (el) {\n        let radius, mesh, distance, extent;\n\n        if (!el.isEntity) { return; }\n\n        mesh = el.getObject3D('mesh');\n\n        if (!mesh) { return; }\n\n        box.setFromObject(mesh).getSize(size);\n        extent = Math.max(size.x, size.y, size.z) / 2;\n        radius = Math.sqrt(2 * extent * extent);\n        box.getCenter(meshPosition);\n\n        if (!radius) { return; }\n\n        distance = position.distanceTo(meshPosition);\n        if (distance < radius + colliderRadius) {\n          collisions.push(el);\n          distanceMap.set(el, distance);\n        }\n      }\n      // use max of scale factors to maintain bounding sphere collision\n      function scaleFactor (scaleVec) {\n        return Math.max(scaleVec.x, scaleVec.y, scaleVec.z);\n      }\n    };\n  })(),\n\n  handleHit: function (targetEl) {\n    targetEl.emit('hit');\n    targetEl.addState(this.data.state);\n    this.eventDetail.el = targetEl;\n    this.el.emit('hit', this.eventDetail);\n  },\n  handleHitEnd: function (targetEl) {\n    targetEl.emit('hitend');\n    targetEl.removeState(this.data.state);\n    this.eventDetail.el = targetEl;\n    this.el.emit('hitend', this.eventDetail);\n  }\n});\n\nfunction copyArray (dest, source) {\n  dest.length = 0;\n  for (let i = 0; i < source.length; i++) { dest[i] = source[i]; }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}