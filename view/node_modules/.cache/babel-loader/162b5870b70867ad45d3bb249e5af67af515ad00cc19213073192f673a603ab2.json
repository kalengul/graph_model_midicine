{"ast":null,"code":"import constant from \"./constant\";\nimport jiggle from \"./jiggle\";\nimport { quadtree } from \"d3-quadtree\";\nimport { x, y } from \"./simulation\";\nexport default function () {\n  var nodes,\n    node,\n    alpha,\n    strength = constant(-30),\n    strengths,\n    distanceMin2 = 1,\n    distanceMax2 = Infinity,\n    theta2 = 0.81;\n  function force(_) {\n    var i,\n      n = nodes.length,\n      tree = quadtree(nodes, x, y).visitAfter(accumulate);\n    for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);\n  }\n  function initialize() {\n    if (!nodes) return;\n    var i,\n      n = nodes.length,\n      node;\n    strengths = new Array(n);\n    for (i = 0; i < n; ++i) node = nodes[i], strengths[node.index] = +strength(node, i, nodes);\n  }\n  function accumulate(quad) {\n    var strength = 0,\n      q,\n      c,\n      weight = 0,\n      x,\n      y,\n      i;\n\n    // For internal nodes, accumulate forces from child quadrants.\n    if (quad.length) {\n      for (x = y = i = 0; i < 4; ++i) {\n        if ((q = quad[i]) && (c = Math.abs(q.value))) {\n          strength += q.value, weight += c, x += c * q.x, y += c * q.y;\n        }\n      }\n      quad.x = x / weight;\n      quad.y = y / weight;\n    }\n\n    // For leaf nodes, accumulate forces from coincident quadrants.\n    else {\n      q = quad;\n      q.x = q.data.x;\n      q.y = q.data.y;\n      do strength += strengths[q.data.index]; while (q = q.next);\n    }\n    quad.value = strength;\n  }\n  function apply(quad, x1, _, x2) {\n    if (!quad.value) return true;\n    var x = quad.x - node.x,\n      y = quad.y - node.y,\n      w = x2 - x1,\n      l = x * x + y * y;\n\n    // Apply the Barnes-Hut approximation if possible.\n    // Limit forces for very close nodes; randomize direction if coincident.\n    if (w * w / theta2 < l) {\n      if (l < distanceMax2) {\n        if (x === 0) x = jiggle(), l += x * x;\n        if (y === 0) y = jiggle(), l += y * y;\n        if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);\n        node.vx += x * quad.value * alpha / l;\n        node.vy += y * quad.value * alpha / l;\n      }\n      return true;\n    }\n\n    // Otherwise, process points directly.\n    else if (quad.length || l >= distanceMax2) return;\n\n    // Limit forces for very close nodes; randomize direction if coincident.\n    if (quad.data !== node || quad.next) {\n      if (x === 0) x = jiggle(), l += x * x;\n      if (y === 0) y = jiggle(), l += y * y;\n      if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);\n    }\n    do if (quad.data !== node) {\n      w = strengths[quad.data.index] * alpha / l;\n      node.vx += x * w;\n      node.vy += y * w;\n    } while (quad = quad.next);\n  }\n  force.initialize = function (_) {\n    nodes = _;\n    initialize();\n  };\n  force.strength = function (_) {\n    return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant(+_), initialize(), force) : strength;\n  };\n  force.distanceMin = function (_) {\n    return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);\n  };\n  force.distanceMax = function (_) {\n    return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);\n  };\n  force.theta = function (_) {\n    return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);\n  };\n  return force;\n}","map":{"version":3,"names":["constant","jiggle","quadtree","x","y","nodes","node","alpha","strength","strengths","distanceMin2","distanceMax2","Infinity","theta2","force","_","i","n","length","tree","visitAfter","accumulate","visit","apply","initialize","Array","index","quad","q","c","weight","Math","abs","value","data","next","x1","x2","w","l","sqrt","vx","vy","arguments","distanceMin","distanceMax","theta"],"sources":["C:/UsersFolders/Polina/РЭУ/Graph/graph_model_midicine/view/node_modules/d3-force/src/manyBody.js"],"sourcesContent":["import constant from \"./constant\";\nimport jiggle from \"./jiggle\";\nimport {quadtree} from \"d3-quadtree\";\nimport {x, y} from \"./simulation\";\n\nexport default function() {\n  var nodes,\n      node,\n      alpha,\n      strength = constant(-30),\n      strengths,\n      distanceMin2 = 1,\n      distanceMax2 = Infinity,\n      theta2 = 0.81;\n\n  function force(_) {\n    var i, n = nodes.length, tree = quadtree(nodes, x, y).visitAfter(accumulate);\n    for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);\n  }\n\n  function initialize() {\n    if (!nodes) return;\n    var i, n = nodes.length, node;\n    strengths = new Array(n);\n    for (i = 0; i < n; ++i) node = nodes[i], strengths[node.index] = +strength(node, i, nodes);\n  }\n\n  function accumulate(quad) {\n    var strength = 0, q, c, weight = 0, x, y, i;\n\n    // For internal nodes, accumulate forces from child quadrants.\n    if (quad.length) {\n      for (x = y = i = 0; i < 4; ++i) {\n        if ((q = quad[i]) && (c = Math.abs(q.value))) {\n          strength += q.value, weight += c, x += c * q.x, y += c * q.y;\n        }\n      }\n      quad.x = x / weight;\n      quad.y = y / weight;\n    }\n\n    // For leaf nodes, accumulate forces from coincident quadrants.\n    else {\n      q = quad;\n      q.x = q.data.x;\n      q.y = q.data.y;\n      do strength += strengths[q.data.index];\n      while (q = q.next);\n    }\n\n    quad.value = strength;\n  }\n\n  function apply(quad, x1, _, x2) {\n    if (!quad.value) return true;\n\n    var x = quad.x - node.x,\n        y = quad.y - node.y,\n        w = x2 - x1,\n        l = x * x + y * y;\n\n    // Apply the Barnes-Hut approximation if possible.\n    // Limit forces for very close nodes; randomize direction if coincident.\n    if (w * w / theta2 < l) {\n      if (l < distanceMax2) {\n        if (x === 0) x = jiggle(), l += x * x;\n        if (y === 0) y = jiggle(), l += y * y;\n        if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);\n        node.vx += x * quad.value * alpha / l;\n        node.vy += y * quad.value * alpha / l;\n      }\n      return true;\n    }\n\n    // Otherwise, process points directly.\n    else if (quad.length || l >= distanceMax2) return;\n\n    // Limit forces for very close nodes; randomize direction if coincident.\n    if (quad.data !== node || quad.next) {\n      if (x === 0) x = jiggle(), l += x * x;\n      if (y === 0) y = jiggle(), l += y * y;\n      if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);\n    }\n\n    do if (quad.data !== node) {\n      w = strengths[quad.data.index] * alpha / l;\n      node.vx += x * w;\n      node.vy += y * w;\n    } while (quad = quad.next);\n  }\n\n  force.initialize = function(_) {\n    nodes = _;\n    initialize();\n  };\n\n  force.strength = function(_) {\n    return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant(+_), initialize(), force) : strength;\n  };\n\n  force.distanceMin = function(_) {\n    return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);\n  };\n\n  force.distanceMax = function(_) {\n    return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);\n  };\n\n  force.theta = function(_) {\n    return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);\n  };\n\n  return force;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}