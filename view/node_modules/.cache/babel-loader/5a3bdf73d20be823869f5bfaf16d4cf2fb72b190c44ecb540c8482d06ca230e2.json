{"ast":null,"code":"const {\n  Pathfinding\n} = require('three-pathfinding');\nconst pathfinder = new Pathfinding();\nconst ZONE = 'level';\n\n/**\n * nav\n *\n * Pathfinding system, using PatrolJS.\n */\nmodule.exports = AFRAME.registerSystem('nav', {\n  init: function () {\n    this.navMesh = null;\n    this.agents = new Set();\n  },\n  /**\n   * @param {THREE.Geometry} geometry\n   */\n  setNavMeshGeometry: function (geometry) {\n    this.navMesh = new THREE.Mesh(geometry);\n    pathfinder.setZoneData(ZONE, Pathfinding.createZone(geometry));\n    Array.from(this.agents).forEach(agent => agent.updateNavLocation());\n  },\n  /**\n   * @return {THREE.Mesh}\n   */\n  getNavMesh: function () {\n    return this.navMesh;\n  },\n  /**\n   * @param {NavAgent} ctrl\n   */\n  addAgent: function (ctrl) {\n    this.agents.add(ctrl);\n  },\n  /**\n   * @param {NavAgent} ctrl\n   */\n  removeAgent: function (ctrl) {\n    this.agents.delete(ctrl);\n  },\n  /**\n   * @param  {THREE.Vector3} start\n   * @param  {THREE.Vector3} end\n   * @param  {number} groupID\n   * @return {Array<THREE.Vector3>}\n   */\n  getPath: function (start, end, groupID) {\n    return this.navMesh ? pathfinder.findPath(start, end, ZONE, groupID) : null;\n  },\n  /**\n   * @param {THREE.Vector3} position\n   * @return {number}\n   */\n  getGroup: function (position) {\n    return this.navMesh ? pathfinder.getGroup(ZONE, position) : null;\n  },\n  /**\n   * @param  {THREE.Vector3} position\n   * @param  {number} groupID\n   * @return {Node}\n   */\n  getNode: function (position, groupID) {\n    return this.navMesh ? pathfinder.getClosestNode(position, ZONE, groupID, true) : null;\n  },\n  /**\n   * @param  {THREE.Vector3} start Starting position.\n   * @param  {THREE.Vector3} end Desired ending position.\n   * @param  {number} groupID\n   * @param  {Node} node\n   * @param  {THREE.Vector3} endTarget (Output) Adjusted step end position.\n   * @return {Node} Current node, after step is taken.\n   */\n  clampStep: function (start, end, groupID, node, endTarget) {\n    if (!this.navMesh) {\n      endTarget.copy(end);\n      return null;\n    } else if (!node) {\n      endTarget.copy(end);\n      return this.getNode(end, groupID);\n    }\n    return pathfinder.clampStep(start, end, node, ZONE, groupID, endTarget);\n  }\n});","map":{"version":3,"names":["Pathfinding","require","pathfinder","ZONE","module","exports","AFRAME","registerSystem","init","navMesh","agents","Set","setNavMeshGeometry","geometry","THREE","Mesh","setZoneData","createZone","Array","from","forEach","agent","updateNavLocation","getNavMesh","addAgent","ctrl","add","removeAgent","delete","getPath","start","end","groupID","findPath","getGroup","position","getNode","getClosestNode","clampStep","node","endTarget","copy"],"sources":["C:/UsersFolders/Polina/РЭУ/Graph/view/node_modules/aframe-extras/src/pathfinding/system.js"],"sourcesContent":["const { Pathfinding } = require('three-pathfinding');\n\nconst pathfinder = new Pathfinding();\nconst ZONE = 'level';\n\n/**\n * nav\n *\n * Pathfinding system, using PatrolJS.\n */\nmodule.exports = AFRAME.registerSystem('nav', {\n  init: function () {\n    this.navMesh = null;\n    this.agents = new Set();\n  },\n\n  /**\n   * @param {THREE.Geometry} geometry\n   */\n  setNavMeshGeometry: function (geometry) {\n    this.navMesh = new THREE.Mesh(geometry);\n    pathfinder.setZoneData(ZONE, Pathfinding.createZone(geometry));\n    Array.from(this.agents).forEach((agent) => agent.updateNavLocation());\n  },\n\n  /**\n   * @return {THREE.Mesh}\n   */\n  getNavMesh: function () {\n    return this.navMesh;\n  },\n\n  /**\n   * @param {NavAgent} ctrl\n   */\n  addAgent: function (ctrl) {\n    this.agents.add(ctrl);\n  },\n\n  /**\n   * @param {NavAgent} ctrl\n   */\n  removeAgent: function (ctrl) {\n    this.agents.delete(ctrl);\n  },\n\n  /**\n   * @param  {THREE.Vector3} start\n   * @param  {THREE.Vector3} end\n   * @param  {number} groupID\n   * @return {Array<THREE.Vector3>}\n   */\n  getPath: function (start, end, groupID) {\n    return this.navMesh\n      ? pathfinder.findPath(start, end, ZONE, groupID)\n      : null;\n  },\n\n  /**\n   * @param {THREE.Vector3} position\n   * @return {number}\n   */\n  getGroup: function (position) {\n    return this.navMesh\n      ? pathfinder.getGroup(ZONE, position)\n      : null;\n  },\n\n  /**\n   * @param  {THREE.Vector3} position\n   * @param  {number} groupID\n   * @return {Node}\n   */\n  getNode: function (position, groupID) {\n    return this.navMesh\n      ? pathfinder.getClosestNode(position, ZONE, groupID, true)\n      : null;\n  },\n\n  /**\n   * @param  {THREE.Vector3} start Starting position.\n   * @param  {THREE.Vector3} end Desired ending position.\n   * @param  {number} groupID\n   * @param  {Node} node\n   * @param  {THREE.Vector3} endTarget (Output) Adjusted step end position.\n   * @return {Node} Current node, after step is taken.\n   */\n  clampStep: function (start, end, groupID, node, endTarget) {\n    if (!this.navMesh) {\n      endTarget.copy(end);\n      return null;\n    } else if (!node) {\n      endTarget.copy(end);\n      return this.getNode(end, groupID);\n    }\n    return pathfinder.clampStep(start, end, node, ZONE, groupID, endTarget);\n  }\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}