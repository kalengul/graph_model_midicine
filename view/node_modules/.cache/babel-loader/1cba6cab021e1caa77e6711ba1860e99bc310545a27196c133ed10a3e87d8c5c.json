{"ast":null,"code":"const LoopMode = {\n  once: THREE.LoopOnce,\n  repeat: THREE.LoopRepeat,\n  pingpong: THREE.LoopPingPong\n};\n\n/**\n * animation-mixer\n *\n * Player for animation clips. Intended to be compatible with any model format that supports\n * skeletal or morph animations through THREE.AnimationMixer.\n * See: https://threejs.org/docs/?q=animation#Reference/Animation/AnimationMixer\n */\nmodule.exports = AFRAME.registerComponent('animation-mixer', {\n  schema: {\n    clip: {\n      default: '*'\n    },\n    useRegExp: {\n      default: false\n    },\n    duration: {\n      default: 0\n    },\n    clampWhenFinished: {\n      default: false,\n      type: 'boolean'\n    },\n    crossFadeDuration: {\n      default: 0\n    },\n    loop: {\n      default: 'repeat',\n      oneOf: Object.keys(LoopMode)\n    },\n    repetitions: {\n      default: Infinity,\n      min: 0\n    },\n    timeScale: {\n      default: 1\n    },\n    startAt: {\n      default: 0\n    }\n  },\n  init: function () {\n    /** @type {THREE.Mesh} */\n    this.model = null;\n    /** @type {THREE.AnimationMixer} */\n    this.mixer = null;\n    /** @type {Array<THREE.AnimationAction>} */\n    this.activeActions = [];\n    const model = this.el.getObject3D('mesh');\n    if (model) {\n      this.load(model);\n    } else {\n      this.el.addEventListener('model-loaded', e => {\n        this.load(e.detail.model);\n      });\n    }\n  },\n  load: function (model) {\n    const el = this.el;\n    this.model = model;\n    this.mixer = new THREE.AnimationMixer(model);\n    this.mixer.addEventListener('loop', e => {\n      el.emit('animation-loop', {\n        action: e.action,\n        loopDelta: e.loopDelta\n      });\n    });\n    this.mixer.addEventListener('finished', e => {\n      el.emit('animation-finished', {\n        action: e.action,\n        direction: e.direction\n      });\n    });\n    if (this.data.clip) this.update({});\n  },\n  remove: function () {\n    if (this.mixer) this.mixer.stopAllAction();\n  },\n  update: function (prevData) {\n    if (!prevData) return;\n    const data = this.data;\n    const changes = AFRAME.utils.diff(data, prevData);\n\n    // If selected clips have changed, restart animation.\n    if ('clip' in changes) {\n      this.stopAction();\n      if (data.clip) this.playAction();\n      return;\n    }\n\n    // Otherwise, modify running actions.\n    this.activeActions.forEach(action => {\n      if ('duration' in changes && data.duration) {\n        action.setDuration(data.duration);\n      }\n      if ('clampWhenFinished' in changes) {\n        action.clampWhenFinished = data.clampWhenFinished;\n      }\n      if ('loop' in changes || 'repetitions' in changes) {\n        action.setLoop(LoopMode[data.loop], data.repetitions);\n      }\n      if ('timeScale' in changes) {\n        action.setEffectiveTimeScale(data.timeScale);\n      }\n    });\n  },\n  stopAction: function () {\n    const data = this.data;\n    for (let i = 0; i < this.activeActions.length; i++) {\n      data.crossFadeDuration ? this.activeActions[i].fadeOut(data.crossFadeDuration) : this.activeActions[i].stop();\n    }\n    this.activeActions.length = 0;\n  },\n  playAction: function () {\n    if (!this.mixer) return;\n    const model = this.model,\n      data = this.data,\n      clips = model.animations || (model.geometry || {}).animations || [];\n    if (!clips.length) return;\n    const re = data.useRegExp ? data.clip : wildcardToRegExp(data.clip);\n    for (let clip, i = 0; clip = clips[i]; i++) {\n      if (clip.name.match(re)) {\n        const action = this.mixer.clipAction(clip, model);\n        action.enabled = true;\n        action.clampWhenFinished = data.clampWhenFinished;\n        if (data.duration) action.setDuration(data.duration);\n        if (data.timeScale !== 1) action.setEffectiveTimeScale(data.timeScale);\n        // animation-mixer.startAt and AnimationAction.startAt have very different meanings.\n        // animation-mixer.startAt indicates which frame in the animation to start at, in msecs.\n        // AnimationAction.startAt indicates when to start the animation (from the 1st frame),\n        // measured in global mixer time, in seconds.\n        action.startAt(this.mixer.time - data.startAt / 1000);\n        action.setLoop(LoopMode[data.loop], data.repetitions).fadeIn(data.crossFadeDuration).play();\n        this.activeActions.push(action);\n      }\n    }\n  },\n  tick: function (t, dt) {\n    if (this.mixer && !isNaN(dt)) this.mixer.update(dt / 1000);\n  }\n});\n\n/**\n * Creates a RegExp from the given string, converting asterisks to .* expressions,\n * and escaping all other characters.\n */\nfunction wildcardToRegExp(s) {\n  return new RegExp('^' + s.split(/\\*+/).map(regExpEscape).join('.*') + '$');\n}\n\n/**\n * RegExp-escapes all characters in the given string.\n */\nfunction regExpEscape(s) {\n  return s.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&');\n}","map":{"version":3,"names":["LoopMode","once","THREE","LoopOnce","repeat","LoopRepeat","pingpong","LoopPingPong","module","exports","AFRAME","registerComponent","schema","clip","default","useRegExp","duration","clampWhenFinished","type","crossFadeDuration","loop","oneOf","Object","keys","repetitions","Infinity","min","timeScale","startAt","init","model","mixer","activeActions","el","getObject3D","load","addEventListener","e","detail","AnimationMixer","emit","action","loopDelta","direction","data","update","remove","stopAllAction","prevData","changes","utils","diff","stopAction","playAction","forEach","setDuration","setLoop","setEffectiveTimeScale","i","length","fadeOut","stop","clips","animations","geometry","re","wildcardToRegExp","name","match","clipAction","enabled","time","fadeIn","play","push","tick","t","dt","isNaN","s","RegExp","split","map","regExpEscape","join","replace"],"sources":["C:/UsersFolders/Polina/РЭУ/Graph/view/node_modules/aframe-extras/src/loaders/animation-mixer.js"],"sourcesContent":["const LoopMode = {\n  once: THREE.LoopOnce,\n  repeat: THREE.LoopRepeat,\n  pingpong: THREE.LoopPingPong\n};\n\n/**\n * animation-mixer\n *\n * Player for animation clips. Intended to be compatible with any model format that supports\n * skeletal or morph animations through THREE.AnimationMixer.\n * See: https://threejs.org/docs/?q=animation#Reference/Animation/AnimationMixer\n */\nmodule.exports = AFRAME.registerComponent('animation-mixer', {\n  schema: {\n    clip: { default: '*' },\n    useRegExp: {default: false},\n    duration: { default: 0 },\n    clampWhenFinished: { default: false, type: 'boolean' },\n    crossFadeDuration: { default: 0 },\n    loop: { default: 'repeat', oneOf: Object.keys(LoopMode) },\n    repetitions: { default: Infinity, min: 0 },\n    timeScale: { default: 1 },\n    startAt: { default: 0 }\n  },\n\n  init: function () {\n    /** @type {THREE.Mesh} */\n    this.model = null;\n    /** @type {THREE.AnimationMixer} */\n    this.mixer = null;\n    /** @type {Array<THREE.AnimationAction>} */\n    this.activeActions = [];\n\n    const model = this.el.getObject3D('mesh');\n\n    if (model) {\n      this.load(model);\n    } else {\n      this.el.addEventListener('model-loaded', (e) => {\n        this.load(e.detail.model);\n      });\n    }\n  },\n\n  load: function (model) {\n    const el = this.el;\n    this.model = model;\n    this.mixer = new THREE.AnimationMixer(model);\n    this.mixer.addEventListener('loop', (e) => {\n      el.emit('animation-loop', { action: e.action, loopDelta: e.loopDelta });\n    });\n    this.mixer.addEventListener('finished', (e) => {\n      el.emit('animation-finished', { action: e.action, direction: e.direction });\n    });\n    if (this.data.clip) this.update({});\n  },\n\n  remove: function () {\n    if (this.mixer) this.mixer.stopAllAction();\n  },\n\n  update: function (prevData) {\n    if (!prevData) return;\n\n    const data = this.data;\n    const changes = AFRAME.utils.diff(data, prevData);\n\n    // If selected clips have changed, restart animation.\n    if ('clip' in changes) {\n      this.stopAction();\n      if (data.clip) this.playAction();\n      return;\n    }\n\n    // Otherwise, modify running actions.\n    this.activeActions.forEach((action) => {\n      if ('duration' in changes && data.duration) {\n        action.setDuration(data.duration);\n      }\n      if ('clampWhenFinished' in changes) {\n        action.clampWhenFinished = data.clampWhenFinished;\n      }\n      if ('loop' in changes || 'repetitions' in changes) {\n        action.setLoop(LoopMode[data.loop], data.repetitions);\n      }\n      if ('timeScale' in changes) {\n        action.setEffectiveTimeScale(data.timeScale);\n      }\n    });\n  },\n\n  stopAction: function () {\n    const data = this.data;\n    for (let i = 0; i < this.activeActions.length; i++) {\n      data.crossFadeDuration\n        ? this.activeActions[i].fadeOut(data.crossFadeDuration)\n        : this.activeActions[i].stop();\n    }\n    this.activeActions.length = 0;\n  },\n\n  playAction: function () {\n    if (!this.mixer) return;\n\n    const model = this.model,\n      data = this.data,\n      clips = model.animations || (model.geometry || {}).animations || [];\n\n    if (!clips.length) return;\n\n    const re = data.useRegExp ? data.clip : wildcardToRegExp(data.clip);\n\n    for (let clip, i = 0; (clip = clips[i]); i++) {\n      if (clip.name.match(re)) {\n        const action = this.mixer.clipAction(clip, model);\n\n        action.enabled = true;\n        action.clampWhenFinished = data.clampWhenFinished;\n        if (data.duration) action.setDuration(data.duration);\n        if (data.timeScale !== 1) action.setEffectiveTimeScale(data.timeScale);\n        // animation-mixer.startAt and AnimationAction.startAt have very different meanings.\n        // animation-mixer.startAt indicates which frame in the animation to start at, in msecs.\n        // AnimationAction.startAt indicates when to start the animation (from the 1st frame),\n        // measured in global mixer time, in seconds.\n        action.startAt(this.mixer.time - data.startAt / 1000);\n        action\n          .setLoop(LoopMode[data.loop], data.repetitions)\n          .fadeIn(data.crossFadeDuration)\n          .play();\n        this.activeActions.push(action);\n      }\n    }\n  },\n\n  tick: function (t, dt) {\n    if (this.mixer && !isNaN(dt)) this.mixer.update(dt / 1000);\n  }\n});\n\n/**\n * Creates a RegExp from the given string, converting asterisks to .* expressions,\n * and escaping all other characters.\n */\nfunction wildcardToRegExp(s) {\n  return new RegExp('^' + s.split(/\\*+/).map(regExpEscape).join('.*') + '$');\n}\n\n/**\n * RegExp-escapes all characters in the given string.\n */\nfunction regExpEscape(s) {\n  return s.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&');\n}\n"],"mappings":"AAAA,MAAMA,QAAQ,GAAG;EACfC,IAAI,EAAEC,KAAK,CAACC,QAAQ;EACpBC,MAAM,EAAEF,KAAK,CAACG,UAAU;EACxBC,QAAQ,EAAEJ,KAAK,CAACK;AAClB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACAC,MAAM,CAACC,OAAO,GAAGC,MAAM,CAACC,iBAAiB,CAAC,iBAAiB,EAAE;EAC3DC,MAAM,EAAE;IACNC,IAAI,EAAE;MAAEC,OAAO,EAAE;IAAI,CAAC;IACtBC,SAAS,EAAE;MAACD,OAAO,EAAE;IAAK,CAAC;IAC3BE,QAAQ,EAAE;MAAEF,OAAO,EAAE;IAAE,CAAC;IACxBG,iBAAiB,EAAE;MAAEH,OAAO,EAAE,KAAK;MAAEI,IAAI,EAAE;IAAU,CAAC;IACtDC,iBAAiB,EAAE;MAAEL,OAAO,EAAE;IAAE,CAAC;IACjCM,IAAI,EAAE;MAAEN,OAAO,EAAE,QAAQ;MAAEO,KAAK,EAAEC,MAAM,CAACC,IAAI,CAACvB,QAAQ;IAAE,CAAC;IACzDwB,WAAW,EAAE;MAAEV,OAAO,EAAEW,QAAQ;MAAEC,GAAG,EAAE;IAAE,CAAC;IAC1CC,SAAS,EAAE;MAAEb,OAAO,EAAE;IAAE,CAAC;IACzBc,OAAO,EAAE;MAAEd,OAAO,EAAE;IAAE;EACxB,CAAC;EAEDe,IAAI,EAAE,SAAAA,CAAA,EAAY;IAChB;IACA,IAAI,CAACC,KAAK,GAAG,IAAI;IACjB;IACA,IAAI,CAACC,KAAK,GAAG,IAAI;IACjB;IACA,IAAI,CAACC,aAAa,GAAG,EAAE;IAEvB,MAAMF,KAAK,GAAG,IAAI,CAACG,EAAE,CAACC,WAAW,CAAC,MAAM,CAAC;IAEzC,IAAIJ,KAAK,EAAE;MACT,IAAI,CAACK,IAAI,CAACL,KAAK,CAAC;IAClB,CAAC,MAAM;MACL,IAAI,CAACG,EAAE,CAACG,gBAAgB,CAAC,cAAc,EAAGC,CAAC,IAAK;QAC9C,IAAI,CAACF,IAAI,CAACE,CAAC,CAACC,MAAM,CAACR,KAAK,CAAC;MAC3B,CAAC,CAAC;IACJ;EACF,CAAC;EAEDK,IAAI,EAAE,SAAAA,CAAUL,KAAK,EAAE;IACrB,MAAMG,EAAE,GAAG,IAAI,CAACA,EAAE;IAClB,IAAI,CAACH,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACC,KAAK,GAAG,IAAI7B,KAAK,CAACqC,cAAc,CAACT,KAAK,CAAC;IAC5C,IAAI,CAACC,KAAK,CAACK,gBAAgB,CAAC,MAAM,EAAGC,CAAC,IAAK;MACzCJ,EAAE,CAACO,IAAI,CAAC,gBAAgB,EAAE;QAAEC,MAAM,EAAEJ,CAAC,CAACI,MAAM;QAAEC,SAAS,EAAEL,CAAC,CAACK;MAAU,CAAC,CAAC;IACzE,CAAC,CAAC;IACF,IAAI,CAACX,KAAK,CAACK,gBAAgB,CAAC,UAAU,EAAGC,CAAC,IAAK;MAC7CJ,EAAE,CAACO,IAAI,CAAC,oBAAoB,EAAE;QAAEC,MAAM,EAAEJ,CAAC,CAACI,MAAM;QAAEE,SAAS,EAAEN,CAAC,CAACM;MAAU,CAAC,CAAC;IAC7E,CAAC,CAAC;IACF,IAAI,IAAI,CAACC,IAAI,CAAC/B,IAAI,EAAE,IAAI,CAACgC,MAAM,CAAC,CAAC,CAAC,CAAC;EACrC,CAAC;EAEDC,MAAM,EAAE,SAAAA,CAAA,EAAY;IAClB,IAAI,IAAI,CAACf,KAAK,EAAE,IAAI,CAACA,KAAK,CAACgB,aAAa,CAAC,CAAC;EAC5C,CAAC;EAEDF,MAAM,EAAE,SAAAA,CAAUG,QAAQ,EAAE;IAC1B,IAAI,CAACA,QAAQ,EAAE;IAEf,MAAMJ,IAAI,GAAG,IAAI,CAACA,IAAI;IACtB,MAAMK,OAAO,GAAGvC,MAAM,CAACwC,KAAK,CAACC,IAAI,CAACP,IAAI,EAAEI,QAAQ,CAAC;;IAEjD;IACA,IAAI,MAAM,IAAIC,OAAO,EAAE;MACrB,IAAI,CAACG,UAAU,CAAC,CAAC;MACjB,IAAIR,IAAI,CAAC/B,IAAI,EAAE,IAAI,CAACwC,UAAU,CAAC,CAAC;MAChC;IACF;;IAEA;IACA,IAAI,CAACrB,aAAa,CAACsB,OAAO,CAAEb,MAAM,IAAK;MACrC,IAAI,UAAU,IAAIQ,OAAO,IAAIL,IAAI,CAAC5B,QAAQ,EAAE;QAC1CyB,MAAM,CAACc,WAAW,CAACX,IAAI,CAAC5B,QAAQ,CAAC;MACnC;MACA,IAAI,mBAAmB,IAAIiC,OAAO,EAAE;QAClCR,MAAM,CAACxB,iBAAiB,GAAG2B,IAAI,CAAC3B,iBAAiB;MACnD;MACA,IAAI,MAAM,IAAIgC,OAAO,IAAI,aAAa,IAAIA,OAAO,EAAE;QACjDR,MAAM,CAACe,OAAO,CAACxD,QAAQ,CAAC4C,IAAI,CAACxB,IAAI,CAAC,EAAEwB,IAAI,CAACpB,WAAW,CAAC;MACvD;MACA,IAAI,WAAW,IAAIyB,OAAO,EAAE;QAC1BR,MAAM,CAACgB,qBAAqB,CAACb,IAAI,CAACjB,SAAS,CAAC;MAC9C;IACF,CAAC,CAAC;EACJ,CAAC;EAEDyB,UAAU,EAAE,SAAAA,CAAA,EAAY;IACtB,MAAMR,IAAI,GAAG,IAAI,CAACA,IAAI;IACtB,KAAK,IAAIc,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAAC1B,aAAa,CAAC2B,MAAM,EAAED,CAAC,EAAE,EAAE;MAClDd,IAAI,CAACzB,iBAAiB,GAClB,IAAI,CAACa,aAAa,CAAC0B,CAAC,CAAC,CAACE,OAAO,CAAChB,IAAI,CAACzB,iBAAiB,CAAC,GACrD,IAAI,CAACa,aAAa,CAAC0B,CAAC,CAAC,CAACG,IAAI,CAAC,CAAC;IAClC;IACA,IAAI,CAAC7B,aAAa,CAAC2B,MAAM,GAAG,CAAC;EAC/B,CAAC;EAEDN,UAAU,EAAE,SAAAA,CAAA,EAAY;IACtB,IAAI,CAAC,IAAI,CAACtB,KAAK,EAAE;IAEjB,MAAMD,KAAK,GAAG,IAAI,CAACA,KAAK;MACtBc,IAAI,GAAG,IAAI,CAACA,IAAI;MAChBkB,KAAK,GAAGhC,KAAK,CAACiC,UAAU,IAAI,CAACjC,KAAK,CAACkC,QAAQ,IAAI,CAAC,CAAC,EAAED,UAAU,IAAI,EAAE;IAErE,IAAI,CAACD,KAAK,CAACH,MAAM,EAAE;IAEnB,MAAMM,EAAE,GAAGrB,IAAI,CAAC7B,SAAS,GAAG6B,IAAI,CAAC/B,IAAI,GAAGqD,gBAAgB,CAACtB,IAAI,CAAC/B,IAAI,CAAC;IAEnE,KAAK,IAAIA,IAAI,EAAE6C,CAAC,GAAG,CAAC,EAAG7C,IAAI,GAAGiD,KAAK,CAACJ,CAAC,CAAC,EAAGA,CAAC,EAAE,EAAE;MAC5C,IAAI7C,IAAI,CAACsD,IAAI,CAACC,KAAK,CAACH,EAAE,CAAC,EAAE;QACvB,MAAMxB,MAAM,GAAG,IAAI,CAACV,KAAK,CAACsC,UAAU,CAACxD,IAAI,EAAEiB,KAAK,CAAC;QAEjDW,MAAM,CAAC6B,OAAO,GAAG,IAAI;QACrB7B,MAAM,CAACxB,iBAAiB,GAAG2B,IAAI,CAAC3B,iBAAiB;QACjD,IAAI2B,IAAI,CAAC5B,QAAQ,EAAEyB,MAAM,CAACc,WAAW,CAACX,IAAI,CAAC5B,QAAQ,CAAC;QACpD,IAAI4B,IAAI,CAACjB,SAAS,KAAK,CAAC,EAAEc,MAAM,CAACgB,qBAAqB,CAACb,IAAI,CAACjB,SAAS,CAAC;QACtE;QACA;QACA;QACA;QACAc,MAAM,CAACb,OAAO,CAAC,IAAI,CAACG,KAAK,CAACwC,IAAI,GAAG3B,IAAI,CAAChB,OAAO,GAAG,IAAI,CAAC;QACrDa,MAAM,CACHe,OAAO,CAACxD,QAAQ,CAAC4C,IAAI,CAACxB,IAAI,CAAC,EAAEwB,IAAI,CAACpB,WAAW,CAAC,CAC9CgD,MAAM,CAAC5B,IAAI,CAACzB,iBAAiB,CAAC,CAC9BsD,IAAI,CAAC,CAAC;QACT,IAAI,CAACzC,aAAa,CAAC0C,IAAI,CAACjC,MAAM,CAAC;MACjC;IACF;EACF,CAAC;EAEDkC,IAAI,EAAE,SAAAA,CAAUC,CAAC,EAAEC,EAAE,EAAE;IACrB,IAAI,IAAI,CAAC9C,KAAK,IAAI,CAAC+C,KAAK,CAACD,EAAE,CAAC,EAAE,IAAI,CAAC9C,KAAK,CAACc,MAAM,CAACgC,EAAE,GAAG,IAAI,CAAC;EAC5D;AACF,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA,SAASX,gBAAgBA,CAACa,CAAC,EAAE;EAC3B,OAAO,IAAIC,MAAM,CAAC,GAAG,GAAGD,CAAC,CAACE,KAAK,CAAC,KAAK,CAAC,CAACC,GAAG,CAACC,YAAY,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC,GAAG,GAAG,CAAC;AAC5E;;AAEA;AACA;AACA;AACA,SAASD,YAAYA,CAACJ,CAAC,EAAE;EACvB,OAAOA,CAAC,CAACM,OAAO,CAAC,qBAAqB,EAAE,MAAM,CAAC;AACjD","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}