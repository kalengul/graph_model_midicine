{"ast":null,"code":"/**\n * @author mrdoob / http://mrdoob.com/\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nmodule.exports = THREE.ColladaLoader = function (manager) {\n  this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n};\nTHREE.ColladaLoader.prototype = {\n  constructor: THREE.ColladaLoader,\n  crossOrigin: 'anonymous',\n  load: function (url, onLoad, onProgress, onError) {\n    var scope = this;\n    var path = scope.path === undefined ? THREE.LoaderUtils.extractUrlBase(url) : scope.path;\n    var loader = new THREE.FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.load(url, function (text) {\n      onLoad(scope.parse(text, path));\n    }, onProgress, onError);\n  },\n  setPath: function (value) {\n    this.path = value;\n    return this;\n  },\n  setResourcePath: function (value) {\n    this.resourcePath = value;\n    return this;\n  },\n  options: {\n    set convertUpAxis(value) {\n      console.warn('THREE.ColladaLoader: options.convertUpAxis() has been removed. Up axis is converted automatically.');\n    }\n  },\n  setCrossOrigin: function (value) {\n    this.crossOrigin = value;\n    return this;\n  },\n  parse: function (text, path) {\n    function getElementsByTagName(xml, name) {\n      // Non recursive xml.getElementsByTagName() ...\n\n      var array = [];\n      var childNodes = xml.childNodes;\n      for (var i = 0, l = childNodes.length; i < l; i++) {\n        var child = childNodes[i];\n        if (child.nodeName === name) {\n          array.push(child);\n        }\n      }\n      return array;\n    }\n    function parseStrings(text) {\n      if (text.length === 0) return [];\n      var parts = text.trim().split(/\\s+/);\n      var array = new Array(parts.length);\n      for (var i = 0, l = parts.length; i < l; i++) {\n        array[i] = parts[i];\n      }\n      return array;\n    }\n    function parseFloats(text) {\n      if (text.length === 0) return [];\n      var parts = text.trim().split(/\\s+/);\n      var array = new Array(parts.length);\n      for (var i = 0, l = parts.length; i < l; i++) {\n        array[i] = parseFloat(parts[i]);\n      }\n      return array;\n    }\n    function parseInts(text) {\n      if (text.length === 0) return [];\n      var parts = text.trim().split(/\\s+/);\n      var array = new Array(parts.length);\n      for (var i = 0, l = parts.length; i < l; i++) {\n        array[i] = parseInt(parts[i]);\n      }\n      return array;\n    }\n    function parseId(text) {\n      return text.substring(1);\n    }\n    function generateId() {\n      return 'three_default_' + count++;\n    }\n    function isEmpty(object) {\n      return Object.keys(object).length === 0;\n    }\n\n    // asset\n\n    function parseAsset(xml) {\n      return {\n        unit: parseAssetUnit(getElementsByTagName(xml, 'unit')[0]),\n        upAxis: parseAssetUpAxis(getElementsByTagName(xml, 'up_axis')[0])\n      };\n    }\n    function parseAssetUnit(xml) {\n      if (xml !== undefined && xml.hasAttribute('meter') === true) {\n        return parseFloat(xml.getAttribute('meter'));\n      } else {\n        return 1; // default 1 meter\n      }\n    }\n    function parseAssetUpAxis(xml) {\n      return xml !== undefined ? xml.textContent : 'Y_UP';\n    }\n\n    // library\n\n    function parseLibrary(xml, libraryName, nodeName, parser) {\n      var library = getElementsByTagName(xml, libraryName)[0];\n      if (library !== undefined) {\n        var elements = getElementsByTagName(library, nodeName);\n        for (var i = 0; i < elements.length; i++) {\n          parser(elements[i]);\n        }\n      }\n    }\n    function buildLibrary(data, builder) {\n      for (var name in data) {\n        var object = data[name];\n        object.build = builder(data[name]);\n      }\n    }\n\n    // get\n\n    function getBuild(data, builder) {\n      if (data.build !== undefined) return data.build;\n      data.build = builder(data);\n      return data.build;\n    }\n\n    // animation\n\n    function parseAnimation(xml) {\n      var data = {\n        sources: {},\n        samplers: {},\n        channels: {}\n      };\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        var id;\n        switch (child.nodeName) {\n          case 'source':\n            id = child.getAttribute('id');\n            data.sources[id] = parseSource(child);\n            break;\n          case 'sampler':\n            id = child.getAttribute('id');\n            data.samplers[id] = parseAnimationSampler(child);\n            break;\n          case 'channel':\n            id = child.getAttribute('target');\n            data.channels[id] = parseAnimationChannel(child);\n            break;\n          default:\n            console.log(child);\n        }\n      }\n      library.animations[xml.getAttribute('id')] = data;\n    }\n    function parseAnimationSampler(xml) {\n      var data = {\n        inputs: {}\n      };\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'input':\n            var id = parseId(child.getAttribute('source'));\n            var semantic = child.getAttribute('semantic');\n            data.inputs[semantic] = id;\n            break;\n        }\n      }\n      return data;\n    }\n    function parseAnimationChannel(xml) {\n      var data = {};\n      var target = xml.getAttribute('target');\n\n      // parsing SID Addressing Syntax\n\n      var parts = target.split('/');\n      var id = parts.shift();\n      var sid = parts.shift();\n\n      // check selection syntax\n\n      var arraySyntax = sid.indexOf('(') !== -1;\n      var memberSyntax = sid.indexOf('.') !== -1;\n      if (memberSyntax) {\n        //  member selection access\n\n        parts = sid.split('.');\n        sid = parts.shift();\n        data.member = parts.shift();\n      } else if (arraySyntax) {\n        // array-access syntax. can be used to express fields in one-dimensional vectors or two-dimensional matrices.\n\n        var indices = sid.split('(');\n        sid = indices.shift();\n        for (var i = 0; i < indices.length; i++) {\n          indices[i] = parseInt(indices[i].replace(/\\)/, ''));\n        }\n        data.indices = indices;\n      }\n      data.id = id;\n      data.sid = sid;\n      data.arraySyntax = arraySyntax;\n      data.memberSyntax = memberSyntax;\n      data.sampler = parseId(xml.getAttribute('source'));\n      return data;\n    }\n    function buildAnimation(data) {\n      var tracks = [];\n      var channels = data.channels;\n      var samplers = data.samplers;\n      var sources = data.sources;\n      for (var target in channels) {\n        if (channels.hasOwnProperty(target)) {\n          var channel = channels[target];\n          var sampler = samplers[channel.sampler];\n          var inputId = sampler.inputs.INPUT;\n          var outputId = sampler.inputs.OUTPUT;\n          var inputSource = sources[inputId];\n          var outputSource = sources[outputId];\n          var animation = buildAnimationChannel(channel, inputSource, outputSource);\n          createKeyframeTracks(animation, tracks);\n        }\n      }\n      return tracks;\n    }\n    function getAnimation(id) {\n      return getBuild(library.animations[id], buildAnimation);\n    }\n    function buildAnimationChannel(channel, inputSource, outputSource) {\n      var node = library.nodes[channel.id];\n      var object3D = getNode(node.id);\n      var transform = node.transforms[channel.sid];\n      var defaultMatrix = node.matrix.clone().transpose();\n      var time, stride;\n      var i, il, j, jl;\n      var data = {};\n\n      // the collada spec allows the animation of data in various ways.\n      // depending on the transform type (matrix, translate, rotate, scale), we execute different logic\n\n      switch (transform) {\n        case 'matrix':\n          for (i = 0, il = inputSource.array.length; i < il; i++) {\n            time = inputSource.array[i];\n            stride = i * outputSource.stride;\n            if (data[time] === undefined) data[time] = {};\n            if (channel.arraySyntax === true) {\n              var value = outputSource.array[stride];\n              var index = channel.indices[0] + 4 * channel.indices[1];\n              data[time][index] = value;\n            } else {\n              for (j = 0, jl = outputSource.stride; j < jl; j++) {\n                data[time][j] = outputSource.array[stride + j];\n              }\n            }\n          }\n          break;\n        case 'translate':\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n          break;\n        case 'rotate':\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n          break;\n        case 'scale':\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n          break;\n      }\n      var keyframes = prepareAnimationData(data, defaultMatrix);\n      var animation = {\n        name: object3D.uuid,\n        keyframes: keyframes\n      };\n      return animation;\n    }\n    function prepareAnimationData(data, defaultMatrix) {\n      var keyframes = [];\n\n      // transfer data into a sortable array\n\n      for (var time in data) {\n        keyframes.push({\n          time: parseFloat(time),\n          value: data[time]\n        });\n      }\n\n      // ensure keyframes are sorted by time\n\n      keyframes.sort(ascending);\n\n      // now we clean up all animation data, so we can use them for keyframe tracks\n\n      for (var i = 0; i < 16; i++) {\n        transformAnimationData(keyframes, i, defaultMatrix.elements[i]);\n      }\n      return keyframes;\n\n      // array sort function\n\n      function ascending(a, b) {\n        return a.time - b.time;\n      }\n    }\n    var position = new THREE.Vector3();\n    var scale = new THREE.Vector3();\n    var quaternion = new THREE.Quaternion();\n    function createKeyframeTracks(animation, tracks) {\n      var keyframes = animation.keyframes;\n      var name = animation.name;\n      var times = [];\n      var positionData = [];\n      var quaternionData = [];\n      var scaleData = [];\n      for (var i = 0, l = keyframes.length; i < l; i++) {\n        var keyframe = keyframes[i];\n        var time = keyframe.time;\n        var value = keyframe.value;\n        matrix.fromArray(value).transpose();\n        matrix.decompose(position, quaternion, scale);\n        times.push(time);\n        positionData.push(position.x, position.y, position.z);\n        quaternionData.push(quaternion.x, quaternion.y, quaternion.z, quaternion.w);\n        scaleData.push(scale.x, scale.y, scale.z);\n      }\n      if (positionData.length > 0) tracks.push(new THREE.VectorKeyframeTrack(name + '.position', times, positionData));\n      if (quaternionData.length > 0) tracks.push(new THREE.QuaternionKeyframeTrack(name + '.quaternion', times, quaternionData));\n      if (scaleData.length > 0) tracks.push(new THREE.VectorKeyframeTrack(name + '.scale', times, scaleData));\n      return tracks;\n    }\n    function transformAnimationData(keyframes, property, defaultValue) {\n      var keyframe;\n      var empty = true;\n      var i, l;\n\n      // check, if values of a property are missing in our keyframes\n\n      for (i = 0, l = keyframes.length; i < l; i++) {\n        keyframe = keyframes[i];\n        if (keyframe.value[property] === undefined) {\n          keyframe.value[property] = null; // mark as missing\n        } else {\n          empty = false;\n        }\n      }\n      if (empty === true) {\n        // no values at all, so we set a default value\n\n        for (i = 0, l = keyframes.length; i < l; i++) {\n          keyframe = keyframes[i];\n          keyframe.value[property] = defaultValue;\n        }\n      } else {\n        // filling gaps\n\n        createMissingKeyframes(keyframes, property);\n      }\n    }\n    function createMissingKeyframes(keyframes, property) {\n      var prev, next;\n      for (var i = 0, l = keyframes.length; i < l; i++) {\n        var keyframe = keyframes[i];\n        if (keyframe.value[property] === null) {\n          prev = getPrev(keyframes, i, property);\n          next = getNext(keyframes, i, property);\n          if (prev === null) {\n            keyframe.value[property] = next.value[property];\n            continue;\n          }\n          if (next === null) {\n            keyframe.value[property] = prev.value[property];\n            continue;\n          }\n          interpolate(keyframe, prev, next, property);\n        }\n      }\n    }\n    function getPrev(keyframes, i, property) {\n      while (i >= 0) {\n        var keyframe = keyframes[i];\n        if (keyframe.value[property] !== null) return keyframe;\n        i--;\n      }\n      return null;\n    }\n    function getNext(keyframes, i, property) {\n      while (i < keyframes.length) {\n        var keyframe = keyframes[i];\n        if (keyframe.value[property] !== null) return keyframe;\n        i++;\n      }\n      return null;\n    }\n    function interpolate(key, prev, next, property) {\n      if (next.time - prev.time === 0) {\n        key.value[property] = prev.value[property];\n        return;\n      }\n      key.value[property] = (key.time - prev.time) * (next.value[property] - prev.value[property]) / (next.time - prev.time) + prev.value[property];\n    }\n\n    // animation clips\n\n    function parseAnimationClip(xml) {\n      var data = {\n        name: xml.getAttribute('id') || 'default',\n        start: parseFloat(xml.getAttribute('start') || 0),\n        end: parseFloat(xml.getAttribute('end') || 0),\n        animations: []\n      };\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'instance_animation':\n            data.animations.push(parseId(child.getAttribute('url')));\n            break;\n        }\n      }\n      library.clips[xml.getAttribute('id')] = data;\n    }\n    function buildAnimationClip(data) {\n      var tracks = [];\n      var name = data.name;\n      var duration = data.end - data.start || -1;\n      var animations = data.animations;\n      for (var i = 0, il = animations.length; i < il; i++) {\n        var animationTracks = getAnimation(animations[i]);\n        for (var j = 0, jl = animationTracks.length; j < jl; j++) {\n          tracks.push(animationTracks[j]);\n        }\n      }\n      return new THREE.AnimationClip(name, duration, tracks);\n    }\n    function getAnimationClip(id) {\n      return getBuild(library.clips[id], buildAnimationClip);\n    }\n\n    // controller\n\n    function parseController(xml) {\n      var data = {};\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'skin':\n            // there is exactly one skin per controller\n            data.id = parseId(child.getAttribute('source'));\n            data.skin = parseSkin(child);\n            break;\n          case 'morph':\n            data.id = parseId(child.getAttribute('source'));\n            console.warn('THREE.ColladaLoader: Morph target animation not supported yet.');\n            break;\n        }\n      }\n      library.controllers[xml.getAttribute('id')] = data;\n    }\n    function parseSkin(xml) {\n      var data = {\n        sources: {}\n      };\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'bind_shape_matrix':\n            data.bindShapeMatrix = parseFloats(child.textContent);\n            break;\n          case 'source':\n            var id = child.getAttribute('id');\n            data.sources[id] = parseSource(child);\n            break;\n          case 'joints':\n            data.joints = parseJoints(child);\n            break;\n          case 'vertex_weights':\n            data.vertexWeights = parseVertexWeights(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseJoints(xml) {\n      var data = {\n        inputs: {}\n      };\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'input':\n            var semantic = child.getAttribute('semantic');\n            var id = parseId(child.getAttribute('source'));\n            data.inputs[semantic] = id;\n            break;\n        }\n      }\n      return data;\n    }\n    function parseVertexWeights(xml) {\n      var data = {\n        inputs: {}\n      };\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'input':\n            var semantic = child.getAttribute('semantic');\n            var id = parseId(child.getAttribute('source'));\n            var offset = parseInt(child.getAttribute('offset'));\n            data.inputs[semantic] = {\n              id: id,\n              offset: offset\n            };\n            break;\n          case 'vcount':\n            data.vcount = parseInts(child.textContent);\n            break;\n          case 'v':\n            data.v = parseInts(child.textContent);\n            break;\n        }\n      }\n      return data;\n    }\n    function buildController(data) {\n      var build = {\n        id: data.id\n      };\n      var geometry = library.geometries[build.id];\n      if (data.skin !== undefined) {\n        build.skin = buildSkin(data.skin);\n\n        // we enhance the 'sources' property of the corresponding geometry with our skin data\n\n        geometry.sources.skinIndices = build.skin.indices;\n        geometry.sources.skinWeights = build.skin.weights;\n      }\n      return build;\n    }\n    function buildSkin(data) {\n      var BONE_LIMIT = 4;\n      var build = {\n        joints: [],\n        // this must be an array to preserve the joint order\n        indices: {\n          array: [],\n          stride: BONE_LIMIT\n        },\n        weights: {\n          array: [],\n          stride: BONE_LIMIT\n        }\n      };\n      var sources = data.sources;\n      var vertexWeights = data.vertexWeights;\n      var vcount = vertexWeights.vcount;\n      var v = vertexWeights.v;\n      var jointOffset = vertexWeights.inputs.JOINT.offset;\n      var weightOffset = vertexWeights.inputs.WEIGHT.offset;\n      var jointSource = data.sources[data.joints.inputs.JOINT];\n      var inverseSource = data.sources[data.joints.inputs.INV_BIND_MATRIX];\n      var weights = sources[vertexWeights.inputs.WEIGHT.id].array;\n      var stride = 0;\n      var i, j, l;\n\n      // procces skin data for each vertex\n\n      for (i = 0, l = vcount.length; i < l; i++) {\n        var jointCount = vcount[i]; // this is the amount of joints that affect a single vertex\n        var vertexSkinData = [];\n        for (j = 0; j < jointCount; j++) {\n          var skinIndex = v[stride + jointOffset];\n          var weightId = v[stride + weightOffset];\n          var skinWeight = weights[weightId];\n          vertexSkinData.push({\n            index: skinIndex,\n            weight: skinWeight\n          });\n          stride += 2;\n        }\n\n        // we sort the joints in descending order based on the weights.\n        // this ensures, we only procced the most important joints of the vertex\n\n        vertexSkinData.sort(descending);\n\n        // now we provide for each vertex a set of four index and weight values.\n        // the order of the skin data matches the order of vertices\n\n        for (j = 0; j < BONE_LIMIT; j++) {\n          var d = vertexSkinData[j];\n          if (d !== undefined) {\n            build.indices.array.push(d.index);\n            build.weights.array.push(d.weight);\n          } else {\n            build.indices.array.push(0);\n            build.weights.array.push(0);\n          }\n        }\n      }\n\n      // setup bind matrix\n\n      if (data.bindShapeMatrix) {\n        build.bindMatrix = new THREE.Matrix4().fromArray(data.bindShapeMatrix).transpose();\n      } else {\n        build.bindMatrix = new THREE.Matrix4().identity();\n      }\n\n      // process bones and inverse bind matrix data\n\n      for (i = 0, l = jointSource.array.length; i < l; i++) {\n        var name = jointSource.array[i];\n        var boneInverse = new THREE.Matrix4().fromArray(inverseSource.array, i * inverseSource.stride).transpose();\n        build.joints.push({\n          name: name,\n          boneInverse: boneInverse\n        });\n      }\n      return build;\n\n      // array sort function\n\n      function descending(a, b) {\n        return b.weight - a.weight;\n      }\n    }\n    function getController(id) {\n      return getBuild(library.controllers[id], buildController);\n    }\n\n    // image\n\n    function parseImage(xml) {\n      var data = {\n        init_from: getElementsByTagName(xml, 'init_from')[0].textContent\n      };\n      library.images[xml.getAttribute('id')] = data;\n    }\n    function buildImage(data) {\n      if (data.build !== undefined) return data.build;\n      return data.init_from;\n    }\n    function getImage(id) {\n      var data = library.images[id];\n      if (data !== undefined) {\n        return getBuild(data, buildImage);\n      }\n      console.warn('THREE.ColladaLoader: Couldn\\'t find image with ID:', id);\n      return null;\n    }\n\n    // effect\n\n    function parseEffect(xml) {\n      var data = {};\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'profile_COMMON':\n            data.profile = parseEffectProfileCOMMON(child);\n            break;\n        }\n      }\n      library.effects[xml.getAttribute('id')] = data;\n    }\n    function parseEffectProfileCOMMON(xml) {\n      var data = {\n        surfaces: {},\n        samplers: {}\n      };\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'newparam':\n            parseEffectNewparam(child, data);\n            break;\n          case 'technique':\n            data.technique = parseEffectTechnique(child);\n            break;\n          case 'extra':\n            data.extra = parseEffectExtra(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectNewparam(xml, data) {\n      var sid = xml.getAttribute('sid');\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'surface':\n            data.surfaces[sid] = parseEffectSurface(child);\n            break;\n          case 'sampler2D':\n            data.samplers[sid] = parseEffectSampler(child);\n            break;\n        }\n      }\n    }\n    function parseEffectSurface(xml) {\n      var data = {};\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'init_from':\n            data.init_from = child.textContent;\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectSampler(xml) {\n      var data = {};\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'source':\n            data.source = child.textContent;\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectTechnique(xml) {\n      var data = {};\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'constant':\n          case 'lambert':\n          case 'blinn':\n          case 'phong':\n            data.type = child.nodeName;\n            data.parameters = parseEffectParameters(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectParameters(xml) {\n      var data = {};\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'emission':\n          case 'diffuse':\n          case 'specular':\n          case 'bump':\n          case 'ambient':\n          case 'shininess':\n          case 'transparency':\n            data[child.nodeName] = parseEffectParameter(child);\n            break;\n          case 'transparent':\n            data[child.nodeName] = {\n              opaque: child.getAttribute('opaque'),\n              data: parseEffectParameter(child)\n            };\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectParameter(xml) {\n      var data = {};\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'color':\n            data[child.nodeName] = parseFloats(child.textContent);\n            break;\n          case 'float':\n            data[child.nodeName] = parseFloat(child.textContent);\n            break;\n          case 'texture':\n            data[child.nodeName] = {\n              id: child.getAttribute('texture'),\n              extra: parseEffectParameterTexture(child)\n            };\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectParameterTexture(xml) {\n      var data = {\n        technique: {}\n      };\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'extra':\n            parseEffectParameterTextureExtra(child, data);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectParameterTextureExtra(xml, data) {\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'technique':\n            parseEffectParameterTextureExtraTechnique(child, data);\n            break;\n        }\n      }\n    }\n    function parseEffectParameterTextureExtraTechnique(xml, data) {\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'repeatU':\n          case 'repeatV':\n          case 'offsetU':\n          case 'offsetV':\n            data.technique[child.nodeName] = parseFloat(child.textContent);\n            break;\n          case 'wrapU':\n          case 'wrapV':\n            // some files have values for wrapU/wrapV which become NaN via parseInt\n\n            if (child.textContent.toUpperCase() === 'TRUE') {\n              data.technique[child.nodeName] = 1;\n            } else if (child.textContent.toUpperCase() === 'FALSE') {\n              data.technique[child.nodeName] = 0;\n            } else {\n              data.technique[child.nodeName] = parseInt(child.textContent);\n            }\n            break;\n        }\n      }\n    }\n    function parseEffectExtra(xml) {\n      var data = {};\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'technique':\n            data.technique = parseEffectExtraTechnique(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectExtraTechnique(xml) {\n      var data = {};\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'double_sided':\n            data[child.nodeName] = parseInt(child.textContent);\n            break;\n        }\n      }\n      return data;\n    }\n    function buildEffect(data) {\n      return data;\n    }\n    function getEffect(id) {\n      return getBuild(library.effects[id], buildEffect);\n    }\n\n    // material\n\n    function parseMaterial(xml) {\n      var data = {\n        name: xml.getAttribute('name')\n      };\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'instance_effect':\n            data.url = parseId(child.getAttribute('url'));\n            break;\n        }\n      }\n      library.materials[xml.getAttribute('id')] = data;\n    }\n    function getTextureLoader(image) {\n      var loader;\n      var extension = image.slice((image.lastIndexOf('.') - 1 >>> 0) + 2); // http://www.jstips.co/en/javascript/get-file-extension/\n      extension = extension.toLowerCase();\n      switch (extension) {\n        case 'tga':\n          loader = tgaLoader;\n          break;\n        default:\n          loader = textureLoader;\n      }\n      return loader;\n    }\n    function buildMaterial(data) {\n      var effect = getEffect(data.url);\n      var technique = effect.profile.technique;\n      var extra = effect.profile.extra;\n      var material;\n      switch (technique.type) {\n        case 'phong':\n        case 'blinn':\n          material = new THREE.MeshPhongMaterial();\n          break;\n        case 'lambert':\n          material = new THREE.MeshLambertMaterial();\n          break;\n        default:\n          material = new THREE.MeshBasicMaterial();\n          break;\n      }\n      material.name = data.name;\n      function getTexture(textureObject) {\n        var sampler = effect.profile.samplers[textureObject.id];\n        var image = null;\n\n        // get image\n\n        if (sampler !== undefined) {\n          var surface = effect.profile.surfaces[sampler.source];\n          image = getImage(surface.init_from);\n        } else {\n          console.warn('THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).');\n          image = getImage(textureObject.id);\n        }\n\n        // create texture if image is avaiable\n\n        if (image !== null) {\n          var loader = getTextureLoader(image);\n          if (loader !== undefined) {\n            var texture = loader.load(image);\n            var extra = textureObject.extra;\n            if (extra !== undefined && extra.technique !== undefined && isEmpty(extra.technique) === false) {\n              var technique = extra.technique;\n              texture.wrapS = technique.wrapU ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n              texture.wrapT = technique.wrapV ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n              texture.offset.set(technique.offsetU || 0, technique.offsetV || 0);\n              texture.repeat.set(technique.repeatU || 1, technique.repeatV || 1);\n            } else {\n              texture.wrapS = THREE.RepeatWrapping;\n              texture.wrapT = THREE.RepeatWrapping;\n            }\n            return texture;\n          } else {\n            console.warn('THREE.ColladaLoader: Loader for texture %s not found.', image);\n            return null;\n          }\n        } else {\n          console.warn('THREE.ColladaLoader: Couldn\\'t create texture with ID:', textureObject.id);\n          return null;\n        }\n      }\n      var parameters = technique.parameters;\n      for (var key in parameters) {\n        var parameter = parameters[key];\n        switch (key) {\n          case 'diffuse':\n            if (parameter.color) material.color.fromArray(parameter.color);\n            if (parameter.texture) material.map = getTexture(parameter.texture);\n            break;\n          case 'specular':\n            if (parameter.color && material.specular) material.specular.fromArray(parameter.color);\n            if (parameter.texture) material.specularMap = getTexture(parameter.texture);\n            break;\n          case 'bump':\n            if (parameter.texture) material.normalMap = getTexture(parameter.texture);\n            break;\n          case 'ambient':\n            if (parameter.texture) material.lightMap = getTexture(parameter.texture);\n            break;\n          case 'shininess':\n            if (parameter.float && material.shininess) material.shininess = parameter.float;\n            break;\n          case 'emission':\n            if (parameter.color && material.emissive) material.emissive.fromArray(parameter.color);\n            if (parameter.texture) material.emissiveMap = getTexture(parameter.texture);\n            break;\n        }\n      }\n\n      //\n\n      var transparent = parameters['transparent'];\n      var transparency = parameters['transparency'];\n\n      // <transparency> does not exist but <transparent>\n\n      if (transparency === undefined && transparent) {\n        transparency = {\n          float: 1\n        };\n      }\n\n      // <transparent> does not exist but <transparency>\n\n      if (transparent === undefined && transparency) {\n        transparent = {\n          opaque: 'A_ONE',\n          data: {\n            color: [1, 1, 1, 1]\n          }\n        };\n      }\n      if (transparent && transparency) {\n        // handle case if a texture exists but no color\n\n        if (transparent.data.texture) {\n          // we do not set an alpha map (see #13792)\n\n          material.transparent = true;\n        } else {\n          var color = transparent.data.color;\n          switch (transparent.opaque) {\n            case 'A_ONE':\n              material.opacity = color[3] * transparency.float;\n              break;\n            case 'RGB_ZERO':\n              material.opacity = 1 - color[0] * transparency.float;\n              break;\n            case 'A_ZERO':\n              material.opacity = 1 - color[3] * transparency.float;\n              break;\n            case 'RGB_ONE':\n              material.opacity = color[0] * transparency.float;\n              break;\n            default:\n              console.warn('THREE.ColladaLoader: Invalid opaque type \"%s\" of transparent tag.', transparent.opaque);\n          }\n          if (material.opacity < 1) material.transparent = true;\n        }\n      }\n\n      //\n\n      if (extra !== undefined && extra.technique !== undefined && extra.technique.double_sided === 1) {\n        material.side = THREE.DoubleSide;\n      }\n      return material;\n    }\n    function getMaterial(id) {\n      return getBuild(library.materials[id], buildMaterial);\n    }\n\n    // camera\n\n    function parseCamera(xml) {\n      var data = {\n        name: xml.getAttribute('name')\n      };\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'optics':\n            data.optics = parseCameraOptics(child);\n            break;\n        }\n      }\n      library.cameras[xml.getAttribute('id')] = data;\n    }\n    function parseCameraOptics(xml) {\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        switch (child.nodeName) {\n          case 'technique_common':\n            return parseCameraTechnique(child);\n        }\n      }\n      return {};\n    }\n    function parseCameraTechnique(xml) {\n      var data = {};\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        switch (child.nodeName) {\n          case 'perspective':\n          case 'orthographic':\n            data.technique = child.nodeName;\n            data.parameters = parseCameraParameters(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseCameraParameters(xml) {\n      var data = {};\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        switch (child.nodeName) {\n          case 'xfov':\n          case 'yfov':\n          case 'xmag':\n          case 'ymag':\n          case 'znear':\n          case 'zfar':\n          case 'aspect_ratio':\n            data[child.nodeName] = parseFloat(child.textContent);\n            break;\n        }\n      }\n      return data;\n    }\n    function buildCamera(data) {\n      var camera;\n      switch (data.optics.technique) {\n        case 'perspective':\n          camera = new THREE.PerspectiveCamera(data.optics.parameters.yfov, data.optics.parameters.aspect_ratio, data.optics.parameters.znear, data.optics.parameters.zfar);\n          break;\n        case 'orthographic':\n          var ymag = data.optics.parameters.ymag;\n          var xmag = data.optics.parameters.xmag;\n          var aspectRatio = data.optics.parameters.aspect_ratio;\n          xmag = xmag === undefined ? ymag * aspectRatio : xmag;\n          ymag = ymag === undefined ? xmag / aspectRatio : ymag;\n          xmag *= 0.5;\n          ymag *= 0.5;\n          camera = new THREE.OrthographicCamera(-xmag, xmag, ymag, -ymag,\n          // left, right, top, bottom\n          data.optics.parameters.znear, data.optics.parameters.zfar);\n          break;\n        default:\n          camera = new THREE.PerspectiveCamera();\n          break;\n      }\n      camera.name = data.name;\n      return camera;\n    }\n    function getCamera(id) {\n      var data = library.cameras[id];\n      if (data !== undefined) {\n        return getBuild(data, buildCamera);\n      }\n      console.warn('THREE.ColladaLoader: Couldn\\'t find camera with ID:', id);\n      return null;\n    }\n\n    // light\n\n    function parseLight(xml) {\n      var data = {};\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'technique_common':\n            data = parseLightTechnique(child);\n            break;\n        }\n      }\n      library.lights[xml.getAttribute('id')] = data;\n    }\n    function parseLightTechnique(xml) {\n      var data = {};\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'directional':\n          case 'point':\n          case 'spot':\n          case 'ambient':\n            data.technique = child.nodeName;\n            data.parameters = parseLightParameters(child);\n        }\n      }\n      return data;\n    }\n    function parseLightParameters(xml) {\n      var data = {};\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'color':\n            var array = parseFloats(child.textContent);\n            data.color = new THREE.Color().fromArray(array);\n            break;\n          case 'falloff_angle':\n            data.falloffAngle = parseFloat(child.textContent);\n            break;\n          case 'quadratic_attenuation':\n            var f = parseFloat(child.textContent);\n            data.distance = f ? Math.sqrt(1 / f) : 0;\n            break;\n        }\n      }\n      return data;\n    }\n    function buildLight(data) {\n      var light;\n      switch (data.technique) {\n        case 'directional':\n          light = new THREE.DirectionalLight();\n          break;\n        case 'point':\n          light = new THREE.PointLight();\n          break;\n        case 'spot':\n          light = new THREE.SpotLight();\n          break;\n        case 'ambient':\n          light = new THREE.AmbientLight();\n          break;\n      }\n      if (data.parameters.color) light.color.copy(data.parameters.color);\n      if (data.parameters.distance) light.distance = data.parameters.distance;\n      return light;\n    }\n    function getLight(id) {\n      var data = library.lights[id];\n      if (data !== undefined) {\n        return getBuild(data, buildLight);\n      }\n      console.warn('THREE.ColladaLoader: Couldn\\'t find light with ID:', id);\n      return null;\n    }\n\n    // geometry\n\n    function parseGeometry(xml) {\n      var data = {\n        name: xml.getAttribute('name'),\n        sources: {},\n        vertices: {},\n        primitives: []\n      };\n      var mesh = getElementsByTagName(xml, 'mesh')[0];\n\n      // the following tags inside geometry are not supported yet (see https://github.com/mrdoob/three.js/pull/12606): convex_mesh, spline, brep\n      if (mesh === undefined) return;\n      for (var i = 0; i < mesh.childNodes.length; i++) {\n        var child = mesh.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        var id = child.getAttribute('id');\n        switch (child.nodeName) {\n          case 'source':\n            data.sources[id] = parseSource(child);\n            break;\n          case 'vertices':\n            // data.sources[ id ] = data.sources[ parseId( getElementsByTagName( child, 'input' )[ 0 ].getAttribute( 'source' ) ) ];\n            data.vertices = parseGeometryVertices(child);\n            break;\n          case 'polygons':\n            console.warn('THREE.ColladaLoader: Unsupported primitive type: ', child.nodeName);\n            break;\n          case 'lines':\n          case 'linestrips':\n          case 'polylist':\n          case 'triangles':\n            data.primitives.push(parseGeometryPrimitive(child));\n            break;\n          default:\n            console.log(child);\n        }\n      }\n      library.geometries[xml.getAttribute('id')] = data;\n    }\n    function parseSource(xml) {\n      var data = {\n        array: [],\n        stride: 3\n      };\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'float_array':\n            data.array = parseFloats(child.textContent);\n            break;\n          case 'Name_array':\n            data.array = parseStrings(child.textContent);\n            break;\n          case 'technique_common':\n            var accessor = getElementsByTagName(child, 'accessor')[0];\n            if (accessor !== undefined) {\n              data.stride = parseInt(accessor.getAttribute('stride'));\n            }\n            break;\n        }\n      }\n      return data;\n    }\n    function parseGeometryVertices(xml) {\n      var data = {};\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        data[child.getAttribute('semantic')] = parseId(child.getAttribute('source'));\n      }\n      return data;\n    }\n    function parseGeometryPrimitive(xml) {\n      var primitive = {\n        type: xml.nodeName,\n        material: xml.getAttribute('material'),\n        count: parseInt(xml.getAttribute('count')),\n        inputs: {},\n        stride: 0,\n        hasUV: false\n      };\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'input':\n            var id = parseId(child.getAttribute('source'));\n            var semantic = child.getAttribute('semantic');\n            var offset = parseInt(child.getAttribute('offset'));\n            var set = parseInt(child.getAttribute('set'));\n            var inputname = set > 0 ? semantic + set : semantic;\n            primitive.inputs[inputname] = {\n              id: id,\n              offset: offset\n            };\n            primitive.stride = Math.max(primitive.stride, offset + 1);\n            if (semantic === 'TEXCOORD') primitive.hasUV = true;\n            break;\n          case 'vcount':\n            primitive.vcount = parseInts(child.textContent);\n            break;\n          case 'p':\n            primitive.p = parseInts(child.textContent);\n            break;\n        }\n      }\n      return primitive;\n    }\n    function groupPrimitives(primitives) {\n      var build = {};\n      for (var i = 0; i < primitives.length; i++) {\n        var primitive = primitives[i];\n        if (build[primitive.type] === undefined) build[primitive.type] = [];\n        build[primitive.type].push(primitive);\n      }\n      return build;\n    }\n    function checkUVCoordinates(primitives) {\n      var count = 0;\n      for (var i = 0, l = primitives.length; i < l; i++) {\n        var primitive = primitives[i];\n        if (primitive.hasUV === true) {\n          count++;\n        }\n      }\n      if (count > 0 && count < primitives.length) {\n        primitives.uvsNeedsFix = true;\n      }\n    }\n    function buildGeometry(data) {\n      var build = {};\n      var sources = data.sources;\n      var vertices = data.vertices;\n      var primitives = data.primitives;\n      if (primitives.length === 0) return {};\n\n      // our goal is to create one buffer geometry for a single type of primitives\n      // first, we group all primitives by their type\n\n      var groupedPrimitives = groupPrimitives(primitives);\n      for (var type in groupedPrimitives) {\n        var primitiveType = groupedPrimitives[type];\n\n        // second, ensure consistent uv coordinates for each type of primitives (polylist,triangles or lines)\n\n        checkUVCoordinates(primitiveType);\n\n        // third, create a buffer geometry for each type of primitives\n\n        build[type] = buildGeometryType(primitiveType, sources, vertices);\n      }\n      return build;\n    }\n    function buildGeometryType(primitives, sources, vertices) {\n      var build = {};\n      var position = {\n        array: [],\n        stride: 0\n      };\n      var normal = {\n        array: [],\n        stride: 0\n      };\n      var uv = {\n        array: [],\n        stride: 0\n      };\n      var uv2 = {\n        array: [],\n        stride: 0\n      };\n      var color = {\n        array: [],\n        stride: 0\n      };\n      var skinIndex = {\n        array: [],\n        stride: 4\n      };\n      var skinWeight = {\n        array: [],\n        stride: 4\n      };\n      var geometry = new THREE.BufferGeometry();\n      var materialKeys = [];\n      var start = 0;\n      for (var p = 0; p < primitives.length; p++) {\n        var primitive = primitives[p];\n        var inputs = primitive.inputs;\n\n        // groups\n\n        var count = 0;\n        switch (primitive.type) {\n          case 'lines':\n          case 'linestrips':\n            count = primitive.count * 2;\n            break;\n          case 'triangles':\n            count = primitive.count * 3;\n            break;\n          case 'polylist':\n            for (var g = 0; g < primitive.count; g++) {\n              var vc = primitive.vcount[g];\n              switch (vc) {\n                case 3:\n                  count += 3; // single triangle\n                  break;\n                case 4:\n                  count += 6; // quad, subdivided into two triangles\n                  break;\n                default:\n                  count += (vc - 2) * 3; // polylist with more than four vertices\n                  break;\n              }\n            }\n            break;\n          default:\n            console.warn('THREE.ColladaLoader: Unknow primitive type:', primitive.type);\n        }\n        geometry.addGroup(start, count, p);\n        start += count;\n\n        // material\n\n        if (primitive.material) {\n          materialKeys.push(primitive.material);\n        }\n\n        // geometry data\n\n        for (var name in inputs) {\n          var input = inputs[name];\n          switch (name) {\n            case 'VERTEX':\n              for (var key in vertices) {\n                var id = vertices[key];\n                switch (key) {\n                  case 'POSITION':\n                    var prevLength = position.array.length;\n                    buildGeometryData(primitive, sources[id], input.offset, position.array);\n                    position.stride = sources[id].stride;\n                    if (sources.skinWeights && sources.skinIndices) {\n                      buildGeometryData(primitive, sources.skinIndices, input.offset, skinIndex.array);\n                      buildGeometryData(primitive, sources.skinWeights, input.offset, skinWeight.array);\n                    }\n\n                    // see #3803\n\n                    if (primitive.hasUV === false && primitives.uvsNeedsFix === true) {\n                      var count = (position.array.length - prevLength) / position.stride;\n                      for (var i = 0; i < count; i++) {\n                        // fill missing uv coordinates\n\n                        uv.array.push(0, 0);\n                      }\n                    }\n                    break;\n                  case 'NORMAL':\n                    buildGeometryData(primitive, sources[id], input.offset, normal.array);\n                    normal.stride = sources[id].stride;\n                    break;\n                  case 'COLOR':\n                    buildGeometryData(primitive, sources[id], input.offset, color.array);\n                    color.stride = sources[id].stride;\n                    break;\n                  case 'TEXCOORD':\n                    buildGeometryData(primitive, sources[id], input.offset, uv.array);\n                    uv.stride = sources[id].stride;\n                    break;\n                  case 'TEXCOORD1':\n                    buildGeometryData(primitive, sources[id], input.offset, uv2.array);\n                    uv.stride = sources[id].stride;\n                    break;\n                  default:\n                    console.warn('THREE.ColladaLoader: Semantic \"%s\" not handled in geometry build process.', key);\n                }\n              }\n              break;\n            case 'NORMAL':\n              buildGeometryData(primitive, sources[input.id], input.offset, normal.array);\n              normal.stride = sources[input.id].stride;\n              break;\n            case 'COLOR':\n              buildGeometryData(primitive, sources[input.id], input.offset, color.array);\n              color.stride = sources[input.id].stride;\n              break;\n            case 'TEXCOORD':\n              buildGeometryData(primitive, sources[input.id], input.offset, uv.array);\n              uv.stride = sources[input.id].stride;\n              break;\n            case 'TEXCOORD1':\n              buildGeometryData(primitive, sources[input.id], input.offset, uv2.array);\n              uv2.stride = sources[input.id].stride;\n              break;\n          }\n        }\n      }\n\n      // build geometry\n\n      if (position.array.length > 0) geometry.addAttribute('position', new THREE.Float32BufferAttribute(position.array, position.stride));\n      if (normal.array.length > 0) geometry.addAttribute('normal', new THREE.Float32BufferAttribute(normal.array, normal.stride));\n      if (color.array.length > 0) geometry.addAttribute('color', new THREE.Float32BufferAttribute(color.array, color.stride));\n      if (uv.array.length > 0) geometry.addAttribute('uv', new THREE.Float32BufferAttribute(uv.array, uv.stride));\n      if (uv2.array.length > 0) geometry.addAttribute('uv2', new THREE.Float32BufferAttribute(uv2.array, uv2.stride));\n      if (skinIndex.array.length > 0) geometry.addAttribute('skinIndex', new THREE.Float32BufferAttribute(skinIndex.array, skinIndex.stride));\n      if (skinWeight.array.length > 0) geometry.addAttribute('skinWeight', new THREE.Float32BufferAttribute(skinWeight.array, skinWeight.stride));\n      build.data = geometry;\n      build.type = primitives[0].type;\n      build.materialKeys = materialKeys;\n      return build;\n    }\n    function buildGeometryData(primitive, source, offset, array) {\n      var indices = primitive.p;\n      var stride = primitive.stride;\n      var vcount = primitive.vcount;\n      function pushVector(i) {\n        var index = indices[i + offset] * sourceStride;\n        var length = index + sourceStride;\n        for (; index < length; index++) {\n          array.push(sourceArray[index]);\n        }\n      }\n      var sourceArray = source.array;\n      var sourceStride = source.stride;\n      if (primitive.vcount !== undefined) {\n        var index = 0;\n        for (var i = 0, l = vcount.length; i < l; i++) {\n          var count = vcount[i];\n          if (count === 4) {\n            var a = index + stride * 0;\n            var b = index + stride * 1;\n            var c = index + stride * 2;\n            var d = index + stride * 3;\n            pushVector(a);\n            pushVector(b);\n            pushVector(d);\n            pushVector(b);\n            pushVector(c);\n            pushVector(d);\n          } else if (count === 3) {\n            var a = index + stride * 0;\n            var b = index + stride * 1;\n            var c = index + stride * 2;\n            pushVector(a);\n            pushVector(b);\n            pushVector(c);\n          } else if (count > 4) {\n            for (var k = 1, kl = count - 2; k <= kl; k++) {\n              var a = index + stride * 0;\n              var b = index + stride * k;\n              var c = index + stride * (k + 1);\n              pushVector(a);\n              pushVector(b);\n              pushVector(c);\n            }\n          }\n          index += stride * count;\n        }\n      } else {\n        for (var i = 0, l = indices.length; i < l; i += stride) {\n          pushVector(i);\n        }\n      }\n    }\n    function getGeometry(id) {\n      return getBuild(library.geometries[id], buildGeometry);\n    }\n\n    // kinematics\n\n    function parseKinematicsModel(xml) {\n      var data = {\n        name: xml.getAttribute('name') || '',\n        joints: {},\n        links: []\n      };\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'technique_common':\n            parseKinematicsTechniqueCommon(child, data);\n            break;\n        }\n      }\n      library.kinematicsModels[xml.getAttribute('id')] = data;\n    }\n    function buildKinematicsModel(data) {\n      if (data.build !== undefined) return data.build;\n      return data;\n    }\n    function getKinematicsModel(id) {\n      return getBuild(library.kinematicsModels[id], buildKinematicsModel);\n    }\n    function parseKinematicsTechniqueCommon(xml, data) {\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'joint':\n            data.joints[child.getAttribute('sid')] = parseKinematicsJoint(child);\n            break;\n          case 'link':\n            data.links.push(parseKinematicsLink(child));\n            break;\n        }\n      }\n    }\n    function parseKinematicsJoint(xml) {\n      var data;\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'prismatic':\n          case 'revolute':\n            data = parseKinematicsJointParameter(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseKinematicsJointParameter(xml, data) {\n      var data = {\n        sid: xml.getAttribute('sid'),\n        name: xml.getAttribute('name') || '',\n        axis: new THREE.Vector3(),\n        limits: {\n          min: 0,\n          max: 0\n        },\n        type: xml.nodeName,\n        static: false,\n        zeroPosition: 0,\n        middlePosition: 0\n      };\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'axis':\n            var array = parseFloats(child.textContent);\n            data.axis.fromArray(array);\n            break;\n          case 'limits':\n            var max = child.getElementsByTagName('max')[0];\n            var min = child.getElementsByTagName('min')[0];\n            data.limits.max = parseFloat(max.textContent);\n            data.limits.min = parseFloat(min.textContent);\n            break;\n        }\n      }\n\n      // if min is equal to or greater than max, consider the joint static\n\n      if (data.limits.min >= data.limits.max) {\n        data.static = true;\n      }\n\n      // calculate middle position\n\n      data.middlePosition = (data.limits.min + data.limits.max) / 2.0;\n      return data;\n    }\n    function parseKinematicsLink(xml) {\n      var data = {\n        sid: xml.getAttribute('sid'),\n        name: xml.getAttribute('name') || '',\n        attachments: [],\n        transforms: []\n      };\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'attachment_full':\n            data.attachments.push(parseKinematicsAttachment(child));\n            break;\n          case 'matrix':\n          case 'translate':\n          case 'rotate':\n            data.transforms.push(parseKinematicsTransform(child));\n            break;\n        }\n      }\n      return data;\n    }\n    function parseKinematicsAttachment(xml) {\n      var data = {\n        joint: xml.getAttribute('joint').split('/').pop(),\n        transforms: [],\n        links: []\n      };\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'link':\n            data.links.push(parseKinematicsLink(child));\n            break;\n          case 'matrix':\n          case 'translate':\n          case 'rotate':\n            data.transforms.push(parseKinematicsTransform(child));\n            break;\n        }\n      }\n      return data;\n    }\n    function parseKinematicsTransform(xml) {\n      var data = {\n        type: xml.nodeName\n      };\n      var array = parseFloats(xml.textContent);\n      switch (data.type) {\n        case 'matrix':\n          data.obj = new THREE.Matrix4();\n          data.obj.fromArray(array).transpose();\n          break;\n        case 'translate':\n          data.obj = new THREE.Vector3();\n          data.obj.fromArray(array);\n          break;\n        case 'rotate':\n          data.obj = new THREE.Vector3();\n          data.obj.fromArray(array);\n          data.angle = THREE.MathUtils.degToRad(array[3]);\n          break;\n      }\n      return data;\n    }\n\n    // physics\n\n    function parsePhysicsModel(xml) {\n      var data = {\n        name: xml.getAttribute('name') || '',\n        rigidBodies: {}\n      };\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'rigid_body':\n            data.rigidBodies[child.getAttribute('name')] = {};\n            parsePhysicsRigidBody(child, data.rigidBodies[child.getAttribute('name')]);\n            break;\n        }\n      }\n      library.physicsModels[xml.getAttribute('id')] = data;\n    }\n    function parsePhysicsRigidBody(xml, data) {\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'technique_common':\n            parsePhysicsTechniqueCommon(child, data);\n            break;\n        }\n      }\n    }\n    function parsePhysicsTechniqueCommon(xml, data) {\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'inertia':\n            data.inertia = parseFloats(child.textContent);\n            break;\n          case 'mass':\n            data.mass = parseFloats(child.textContent)[0];\n            break;\n        }\n      }\n    }\n\n    // scene\n\n    function parseKinematicsScene(xml) {\n      var data = {\n        bindJointAxis: []\n      };\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'bind_joint_axis':\n            data.bindJointAxis.push(parseKinematicsBindJointAxis(child));\n            break;\n        }\n      }\n      library.kinematicsScenes[parseId(xml.getAttribute('url'))] = data;\n    }\n    function parseKinematicsBindJointAxis(xml) {\n      var data = {\n        target: xml.getAttribute('target').split('/').pop()\n      };\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'axis':\n            var param = child.getElementsByTagName('param')[0];\n            data.axis = param.textContent;\n            var tmpJointIndex = data.axis.split('inst_').pop().split('axis')[0];\n            data.jointIndex = tmpJointIndex.substr(0, tmpJointIndex.length - 1);\n            break;\n        }\n      }\n      return data;\n    }\n    function buildKinematicsScene(data) {\n      if (data.build !== undefined) return data.build;\n      return data;\n    }\n    function getKinematicsScene(id) {\n      return getBuild(library.kinematicsScenes[id], buildKinematicsScene);\n    }\n    function setupKinematics() {\n      var kinematicsModelId = Object.keys(library.kinematicsModels)[0];\n      var kinematicsSceneId = Object.keys(library.kinematicsScenes)[0];\n      var visualSceneId = Object.keys(library.visualScenes)[0];\n      if (kinematicsModelId === undefined || kinematicsSceneId === undefined) return;\n      var kinematicsModel = getKinematicsModel(kinematicsModelId);\n      var kinematicsScene = getKinematicsScene(kinematicsSceneId);\n      var visualScene = getVisualScene(visualSceneId);\n      var bindJointAxis = kinematicsScene.bindJointAxis;\n      var jointMap = {};\n      for (var i = 0, l = bindJointAxis.length; i < l; i++) {\n        var axis = bindJointAxis[i];\n\n        // the result of the following query is an element of type 'translate', 'rotate','scale' or 'matrix'\n\n        var targetElement = collada.querySelector('[sid=\"' + axis.target + '\"]');\n        if (targetElement) {\n          // get the parent of the transfrom element\n\n          var parentVisualElement = targetElement.parentElement;\n\n          // connect the joint of the kinematics model with the element in the visual scene\n\n          connect(axis.jointIndex, parentVisualElement);\n        }\n      }\n      function connect(jointIndex, visualElement) {\n        var visualElementName = visualElement.getAttribute('name');\n        var joint = kinematicsModel.joints[jointIndex];\n        visualScene.traverse(function (object) {\n          if (object.name === visualElementName) {\n            jointMap[jointIndex] = {\n              object: object,\n              transforms: buildTransformList(visualElement),\n              joint: joint,\n              position: joint.zeroPosition\n            };\n          }\n        });\n      }\n      var m0 = new THREE.Matrix4();\n      kinematics = {\n        joints: kinematicsModel && kinematicsModel.joints,\n        getJointValue: function (jointIndex) {\n          var jointData = jointMap[jointIndex];\n          if (jointData) {\n            return jointData.position;\n          } else {\n            console.warn('THREE.ColladaLoader: Joint ' + jointIndex + ' doesn\\'t exist.');\n          }\n        },\n        setJointValue: function (jointIndex, value) {\n          var jointData = jointMap[jointIndex];\n          if (jointData) {\n            var joint = jointData.joint;\n            if (value > joint.limits.max || value < joint.limits.min) {\n              console.warn('THREE.ColladaLoader: Joint ' + jointIndex + ' value ' + value + ' outside of limits (min: ' + joint.limits.min + ', max: ' + joint.limits.max + ').');\n            } else if (joint.static) {\n              console.warn('THREE.ColladaLoader: Joint ' + jointIndex + ' is static.');\n            } else {\n              var object = jointData.object;\n              var axis = joint.axis;\n              var transforms = jointData.transforms;\n              matrix.identity();\n\n              // each update, we have to apply all transforms in the correct order\n\n              for (var i = 0; i < transforms.length; i++) {\n                var transform = transforms[i];\n\n                // if there is a connection of the transform node with a joint, apply the joint value\n\n                if (transform.sid && transform.sid.indexOf(jointIndex) !== -1) {\n                  switch (joint.type) {\n                    case 'revolute':\n                      matrix.multiply(m0.makeRotationAxis(axis, THREE.MathUtils.degToRad(value)));\n                      break;\n                    case 'prismatic':\n                      matrix.multiply(m0.makeTranslation(axis.x * value, axis.y * value, axis.z * value));\n                      break;\n                    default:\n                      console.warn('THREE.ColladaLoader: Unknown joint type: ' + joint.type);\n                      break;\n                  }\n                } else {\n                  switch (transform.type) {\n                    case 'matrix':\n                      matrix.multiply(transform.obj);\n                      break;\n                    case 'translate':\n                      matrix.multiply(m0.makeTranslation(transform.obj.x, transform.obj.y, transform.obj.z));\n                      break;\n                    case 'scale':\n                      matrix.scale(transform.obj);\n                      break;\n                    case 'rotate':\n                      matrix.multiply(m0.makeRotationAxis(transform.obj, transform.angle));\n                      break;\n                  }\n                }\n              }\n              object.matrix.copy(matrix);\n              object.matrix.decompose(object.position, object.quaternion, object.scale);\n              jointMap[jointIndex].position = value;\n            }\n          } else {\n            console.log('THREE.ColladaLoader: ' + jointIndex + ' does not exist.');\n          }\n        }\n      };\n    }\n    function buildTransformList(node) {\n      var transforms = [];\n      var xml = collada.querySelector('[id=\"' + node.id + '\"]');\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'matrix':\n            var array = parseFloats(child.textContent);\n            var matrix = new THREE.Matrix4().fromArray(array).transpose();\n            transforms.push({\n              sid: child.getAttribute('sid'),\n              type: child.nodeName,\n              obj: matrix\n            });\n            break;\n          case 'translate':\n          case 'scale':\n            var array = parseFloats(child.textContent);\n            var vector = new THREE.Vector3().fromArray(array);\n            transforms.push({\n              sid: child.getAttribute('sid'),\n              type: child.nodeName,\n              obj: vector\n            });\n            break;\n          case 'rotate':\n            var array = parseFloats(child.textContent);\n            var vector = new THREE.Vector3().fromArray(array);\n            var angle = THREE.MathUtils.degToRad(array[3]);\n            transforms.push({\n              sid: child.getAttribute('sid'),\n              type: child.nodeName,\n              obj: vector,\n              angle: angle\n            });\n            break;\n        }\n      }\n      return transforms;\n    }\n\n    // nodes\n\n    function prepareNodes(xml) {\n      var elements = xml.getElementsByTagName('node');\n\n      // ensure all node elements have id attributes\n\n      for (var i = 0; i < elements.length; i++) {\n        var element = elements[i];\n        if (element.hasAttribute('id') === false) {\n          element.setAttribute('id', generateId());\n        }\n      }\n    }\n    var matrix = new THREE.Matrix4();\n    var vector = new THREE.Vector3();\n    function parseNode(xml) {\n      var data = {\n        name: xml.getAttribute('name') || '',\n        type: xml.getAttribute('type'),\n        id: xml.getAttribute('id'),\n        sid: xml.getAttribute('sid'),\n        matrix: new THREE.Matrix4(),\n        nodes: [],\n        instanceCameras: [],\n        instanceControllers: [],\n        instanceLights: [],\n        instanceGeometries: [],\n        instanceNodes: [],\n        transforms: {}\n      };\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'node':\n            data.nodes.push(child.getAttribute('id'));\n            parseNode(child);\n            break;\n          case 'instance_camera':\n            data.instanceCameras.push(parseId(child.getAttribute('url')));\n            break;\n          case 'instance_controller':\n            data.instanceControllers.push(parseNodeInstance(child));\n            break;\n          case 'instance_light':\n            data.instanceLights.push(parseId(child.getAttribute('url')));\n            break;\n          case 'instance_geometry':\n            data.instanceGeometries.push(parseNodeInstance(child));\n            break;\n          case 'instance_node':\n            data.instanceNodes.push(parseId(child.getAttribute('url')));\n            break;\n          case 'matrix':\n            var array = parseFloats(child.textContent);\n            data.matrix.multiply(matrix.fromArray(array).transpose());\n            data.transforms[child.getAttribute('sid')] = child.nodeName;\n            break;\n          case 'translate':\n            var array = parseFloats(child.textContent);\n            vector.fromArray(array);\n            data.matrix.multiply(matrix.makeTranslation(vector.x, vector.y, vector.z));\n            data.transforms[child.getAttribute('sid')] = child.nodeName;\n            break;\n          case 'rotate':\n            var array = parseFloats(child.textContent);\n            var angle = THREE.MathUtils.degToRad(array[3]);\n            data.matrix.multiply(matrix.makeRotationAxis(vector.fromArray(array), angle));\n            data.transforms[child.getAttribute('sid')] = child.nodeName;\n            break;\n          case 'scale':\n            var array = parseFloats(child.textContent);\n            data.matrix.scale(vector.fromArray(array));\n            data.transforms[child.getAttribute('sid')] = child.nodeName;\n            break;\n          case 'extra':\n            break;\n          default:\n            console.log(child);\n        }\n      }\n      if (hasNode(data.id)) {\n        console.warn('THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.', data.id);\n      } else {\n        library.nodes[data.id] = data;\n      }\n      return data;\n    }\n    function parseNodeInstance(xml) {\n      var data = {\n        id: parseId(xml.getAttribute('url')),\n        materials: {},\n        skeletons: []\n      };\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        switch (child.nodeName) {\n          case 'bind_material':\n            var instances = child.getElementsByTagName('instance_material');\n            for (var j = 0; j < instances.length; j++) {\n              var instance = instances[j];\n              var symbol = instance.getAttribute('symbol');\n              var target = instance.getAttribute('target');\n              data.materials[symbol] = parseId(target);\n            }\n            break;\n          case 'skeleton':\n            data.skeletons.push(parseId(child.textContent));\n            break;\n          default:\n            break;\n        }\n      }\n      return data;\n    }\n    function buildSkeleton(skeletons, joints) {\n      var boneData = [];\n      var sortedBoneData = [];\n      var i, j, data;\n\n      // a skeleton can have multiple root bones. collada expresses this\n      // situtation with multiple \"skeleton\" tags per controller instance\n\n      for (i = 0; i < skeletons.length; i++) {\n        var skeleton = skeletons[i];\n        var root;\n        if (hasNode(skeleton)) {\n          root = getNode(skeleton);\n          buildBoneHierarchy(root, joints, boneData);\n        } else if (hasVisualScene(skeleton)) {\n          // handle case where the skeleton refers to the visual scene (#13335)\n\n          var visualScene = library.visualScenes[skeleton];\n          var children = visualScene.children;\n          for (var j = 0; j < children.length; j++) {\n            var child = children[j];\n            if (child.type === 'JOINT') {\n              var root = getNode(child.id);\n              buildBoneHierarchy(root, joints, boneData);\n            }\n          }\n        } else {\n          console.error('THREE.ColladaLoader: Unable to find root bone of skeleton with ID:', skeleton);\n        }\n      }\n\n      // sort bone data (the order is defined in the corresponding controller)\n\n      for (i = 0; i < joints.length; i++) {\n        for (j = 0; j < boneData.length; j++) {\n          data = boneData[j];\n          if (data.bone.name === joints[i].name) {\n            sortedBoneData[i] = data;\n            data.processed = true;\n            break;\n          }\n        }\n      }\n\n      // add unprocessed bone data at the end of the list\n\n      for (i = 0; i < boneData.length; i++) {\n        data = boneData[i];\n        if (data.processed === false) {\n          sortedBoneData.push(data);\n          data.processed = true;\n        }\n      }\n\n      // setup arrays for skeleton creation\n\n      var bones = [];\n      var boneInverses = [];\n      for (i = 0; i < sortedBoneData.length; i++) {\n        data = sortedBoneData[i];\n        bones.push(data.bone);\n        boneInverses.push(data.boneInverse);\n      }\n      return new THREE.Skeleton(bones, boneInverses);\n    }\n    function buildBoneHierarchy(root, joints, boneData) {\n      // setup bone data from visual scene\n\n      root.traverse(function (object) {\n        if (object.isBone === true) {\n          var boneInverse;\n\n          // retrieve the boneInverse from the controller data\n\n          for (var i = 0; i < joints.length; i++) {\n            var joint = joints[i];\n            if (joint.name === object.name) {\n              boneInverse = joint.boneInverse;\n              break;\n            }\n          }\n          if (boneInverse === undefined) {\n            // Unfortunately, there can be joints in the visual scene that are not part of the\n            // corresponding controller. In this case, we have to create a dummy boneInverse matrix\n            // for the respective bone. This bone won't affect any vertices, because there are no skin indices\n            // and weights defined for it. But we still have to add the bone to the sorted bone list in order to\n            // ensure a correct animation of the model.\n\n            boneInverse = new THREE.Matrix4();\n          }\n          boneData.push({\n            bone: object,\n            boneInverse: boneInverse,\n            processed: false\n          });\n        }\n      });\n    }\n    function buildNode(data) {\n      var objects = [];\n      var matrix = data.matrix;\n      var nodes = data.nodes;\n      var type = data.type;\n      var instanceCameras = data.instanceCameras;\n      var instanceControllers = data.instanceControllers;\n      var instanceLights = data.instanceLights;\n      var instanceGeometries = data.instanceGeometries;\n      var instanceNodes = data.instanceNodes;\n\n      // nodes\n\n      for (var i = 0, l = nodes.length; i < l; i++) {\n        objects.push(getNode(nodes[i]));\n      }\n\n      // instance cameras\n\n      for (var i = 0, l = instanceCameras.length; i < l; i++) {\n        var instanceCamera = getCamera(instanceCameras[i]);\n        if (instanceCamera !== null) {\n          objects.push(instanceCamera.clone());\n        }\n      }\n\n      // instance controllers\n\n      for (var i = 0, l = instanceControllers.length; i < l; i++) {\n        var instance = instanceControllers[i];\n        var controller = getController(instance.id);\n        var geometries = getGeometry(controller.id);\n        var newObjects = buildObjects(geometries, instance.materials);\n        var skeletons = instance.skeletons;\n        var joints = controller.skin.joints;\n        var skeleton = buildSkeleton(skeletons, joints);\n        for (var j = 0, jl = newObjects.length; j < jl; j++) {\n          var object = newObjects[j];\n          if (object.isSkinnedMesh) {\n            object.bind(skeleton, controller.skin.bindMatrix);\n            object.normalizeSkinWeights();\n          }\n          objects.push(object);\n        }\n      }\n\n      // instance lights\n\n      for (var i = 0, l = instanceLights.length; i < l; i++) {\n        var instanceLight = getLight(instanceLights[i]);\n        if (instanceLight !== null) {\n          objects.push(instanceLight.clone());\n        }\n      }\n\n      // instance geometries\n\n      for (var i = 0, l = instanceGeometries.length; i < l; i++) {\n        var instance = instanceGeometries[i];\n\n        // a single geometry instance in collada can lead to multiple object3Ds.\n        // this is the case when primitives are combined like triangles and lines\n\n        var geometries = getGeometry(instance.id);\n        var newObjects = buildObjects(geometries, instance.materials);\n        for (var j = 0, jl = newObjects.length; j < jl; j++) {\n          objects.push(newObjects[j]);\n        }\n      }\n\n      // instance nodes\n\n      for (var i = 0, l = instanceNodes.length; i < l; i++) {\n        objects.push(getNode(instanceNodes[i]).clone());\n      }\n      var object;\n      if (nodes.length === 0 && objects.length === 1) {\n        object = objects[0];\n      } else {\n        object = type === 'JOINT' ? new THREE.Bone() : new THREE.Group();\n        for (var i = 0; i < objects.length; i++) {\n          object.add(objects[i]);\n        }\n      }\n      if (object.name === '') {\n        object.name = type === 'JOINT' ? data.sid : data.name;\n      }\n      object.matrix.copy(matrix);\n      object.matrix.decompose(object.position, object.quaternion, object.scale);\n      return object;\n    }\n    var fallbackMaterial = new THREE.MeshBasicMaterial({\n      color: 0xff00ff\n    });\n    function resolveMaterialBinding(keys, instanceMaterials) {\n      var materials = [];\n      for (var i = 0, l = keys.length; i < l; i++) {\n        var id = instanceMaterials[keys[i]];\n        if (id === undefined) {\n          console.warn('THREE.ColladaLoader: Material with key %s not found. Apply fallback material.', keys[i]);\n          materials.push(fallbackMaterial);\n        } else {\n          materials.push(getMaterial(id));\n        }\n      }\n      return materials;\n    }\n    function buildObjects(geometries, instanceMaterials) {\n      var objects = [];\n      for (var type in geometries) {\n        var geometry = geometries[type];\n        var materials = resolveMaterialBinding(geometry.materialKeys, instanceMaterials);\n\n        // handle case if no materials are defined\n\n        if (materials.length === 0) {\n          if (type === 'lines' || type === 'linestrips') {\n            materials.push(new THREE.LineBasicMaterial());\n          } else {\n            materials.push(new THREE.MeshPhongMaterial());\n          }\n        }\n\n        // regard skinning\n\n        var skinning = geometry.data.attributes.skinIndex !== undefined;\n        if (skinning) {\n          for (var i = 0, l = materials.length; i < l; i++) {\n            materials[i].skinning = true;\n          }\n        }\n\n        // choose between a single or multi materials (material array)\n\n        var material = materials.length === 1 ? materials[0] : materials;\n\n        // now create a specific 3D object\n\n        var object;\n        switch (type) {\n          case 'lines':\n            object = new THREE.LineSegments(geometry.data, material);\n            break;\n          case 'linestrips':\n            object = new THREE.Line(geometry.data, material);\n            break;\n          case 'triangles':\n          case 'polylist':\n            if (skinning) {\n              object = new THREE.SkinnedMesh(geometry.data, material);\n            } else {\n              object = new THREE.Mesh(geometry.data, material);\n            }\n            break;\n        }\n        objects.push(object);\n      }\n      return objects;\n    }\n    function hasNode(id) {\n      return library.nodes[id] !== undefined;\n    }\n    function getNode(id) {\n      return getBuild(library.nodes[id], buildNode);\n    }\n\n    // visual scenes\n\n    function parseVisualScene(xml) {\n      var data = {\n        name: xml.getAttribute('name'),\n        children: []\n      };\n      prepareNodes(xml);\n      var elements = getElementsByTagName(xml, 'node');\n      for (var i = 0; i < elements.length; i++) {\n        data.children.push(parseNode(elements[i]));\n      }\n      library.visualScenes[xml.getAttribute('id')] = data;\n    }\n    function buildVisualScene(data) {\n      var group = new THREE.Group();\n      group.name = data.name;\n      var children = data.children;\n      for (var i = 0; i < children.length; i++) {\n        var child = children[i];\n        group.add(getNode(child.id));\n      }\n      return group;\n    }\n    function hasVisualScene(id) {\n      return library.visualScenes[id] !== undefined;\n    }\n    function getVisualScene(id) {\n      return getBuild(library.visualScenes[id], buildVisualScene);\n    }\n\n    // scenes\n\n    function parseScene(xml) {\n      var instance = getElementsByTagName(xml, 'instance_visual_scene')[0];\n      return getVisualScene(parseId(instance.getAttribute('url')));\n    }\n    function setupAnimations() {\n      var clips = library.clips;\n      if (isEmpty(clips) === true) {\n        if (isEmpty(library.animations) === false) {\n          // if there are animations but no clips, we create a default clip for playback\n\n          var tracks = [];\n          for (var id in library.animations) {\n            var animationTracks = getAnimation(id);\n            for (var i = 0, l = animationTracks.length; i < l; i++) {\n              tracks.push(animationTracks[i]);\n            }\n          }\n          animations.push(new THREE.AnimationClip('default', -1, tracks));\n        }\n      } else {\n        for (var id in clips) {\n          animations.push(getAnimationClip(id));\n        }\n      }\n    }\n    if (text.length === 0) {\n      return {\n        scene: new THREE.Scene()\n      };\n    }\n    var xml = new DOMParser().parseFromString(text, 'application/xml');\n    var collada = getElementsByTagName(xml, 'COLLADA')[0];\n\n    // metadata\n\n    var version = collada.getAttribute('version');\n    console.log('THREE.ColladaLoader: File version', version);\n    var asset = parseAsset(getElementsByTagName(collada, 'asset')[0]);\n    var textureLoader = new THREE.TextureLoader(this.manager);\n    textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n    var tgaLoader;\n    if (THREE.TGALoader) {\n      tgaLoader = new THREE.TGALoader(this.manager);\n      tgaLoader.setPath(this.resourcePath || path);\n    }\n\n    //\n\n    var animations = [];\n    var kinematics = {};\n    var count = 0;\n\n    //\n\n    var library = {\n      animations: {},\n      clips: {},\n      controllers: {},\n      images: {},\n      effects: {},\n      materials: {},\n      cameras: {},\n      lights: {},\n      geometries: {},\n      nodes: {},\n      visualScenes: {},\n      kinematicsModels: {},\n      physicsModels: {},\n      kinematicsScenes: {}\n    };\n    parseLibrary(collada, 'library_animations', 'animation', parseAnimation);\n    parseLibrary(collada, 'library_animation_clips', 'animation_clip', parseAnimationClip);\n    parseLibrary(collada, 'library_controllers', 'controller', parseController);\n    parseLibrary(collada, 'library_images', 'image', parseImage);\n    parseLibrary(collada, 'library_effects', 'effect', parseEffect);\n    parseLibrary(collada, 'library_materials', 'material', parseMaterial);\n    parseLibrary(collada, 'library_cameras', 'camera', parseCamera);\n    parseLibrary(collada, 'library_lights', 'light', parseLight);\n    parseLibrary(collada, 'library_geometries', 'geometry', parseGeometry);\n    parseLibrary(collada, 'library_nodes', 'node', parseNode);\n    parseLibrary(collada, 'library_visual_scenes', 'visual_scene', parseVisualScene);\n    parseLibrary(collada, 'library_kinematics_models', 'kinematics_model', parseKinematicsModel);\n    parseLibrary(collada, 'library_physics_models', 'physics_model', parsePhysicsModel);\n    parseLibrary(collada, 'scene', 'instance_kinematics_scene', parseKinematicsScene);\n    buildLibrary(library.animations, buildAnimation);\n    buildLibrary(library.clips, buildAnimationClip);\n    buildLibrary(library.controllers, buildController);\n    buildLibrary(library.images, buildImage);\n    buildLibrary(library.effects, buildEffect);\n    buildLibrary(library.materials, buildMaterial);\n    buildLibrary(library.cameras, buildCamera);\n    buildLibrary(library.lights, buildLight);\n    buildLibrary(library.geometries, buildGeometry);\n    buildLibrary(library.visualScenes, buildVisualScene);\n    setupAnimations();\n    setupKinematics();\n    var scene = parseScene(getElementsByTagName(collada, 'scene')[0]);\n    if (asset.upAxis === 'Z_UP') {\n      scene.quaternion.setFromEuler(new THREE.Euler(-Math.PI / 2, 0, 0));\n    }\n    scene.scale.multiplyScalar(asset.unit);\n    return {\n      animations: animations,\n      kinematics: kinematics,\n      library: library,\n      scene: scene\n    };\n  }\n};","map":{"version":3,"names":["module","exports","THREE","ColladaLoader","manager","undefined","DefaultLoadingManager","prototype","constructor","crossOrigin","load","url","onLoad","onProgress","onError","scope","path","LoaderUtils","extractUrlBase","loader","FileLoader","setPath","text","parse","value","setResourcePath","resourcePath","options","convertUpAxis","console","warn","setCrossOrigin","getElementsByTagName","xml","name","array","childNodes","i","l","length","child","nodeName","push","parseStrings","parts","trim","split","Array","parseFloats","parseFloat","parseInts","parseInt","parseId","substring","generateId","count","isEmpty","object","Object","keys","parseAsset","unit","parseAssetUnit","upAxis","parseAssetUpAxis","hasAttribute","getAttribute","textContent","parseLibrary","libraryName","parser","library","elements","buildLibrary","data","builder","build","getBuild","parseAnimation","sources","samplers","channels","nodeType","id","parseSource","parseAnimationSampler","parseAnimationChannel","log","animations","inputs","semantic","target","shift","sid","arraySyntax","indexOf","memberSyntax","member","indices","replace","sampler","buildAnimation","tracks","hasOwnProperty","channel","inputId","INPUT","outputId","OUTPUT","inputSource","outputSource","animation","buildAnimationChannel","createKeyframeTracks","getAnimation","node","nodes","object3D","getNode","transform","transforms","defaultMatrix","matrix","clone","transpose","time","stride","il","j","jl","index","keyframes","prepareAnimationData","uuid","sort","ascending","transformAnimationData","a","b","position","Vector3","scale","quaternion","Quaternion","times","positionData","quaternionData","scaleData","keyframe","fromArray","decompose","x","y","z","w","VectorKeyframeTrack","QuaternionKeyframeTrack","property","defaultValue","empty","createMissingKeyframes","prev","next","getPrev","getNext","interpolate","key","parseAnimationClip","start","end","clips","buildAnimationClip","duration","animationTracks","AnimationClip","getAnimationClip","parseController","skin","parseSkin","controllers","bindShapeMatrix","joints","parseJoints","vertexWeights","parseVertexWeights","offset","vcount","v","buildController","geometry","geometries","buildSkin","skinIndices","skinWeights","weights","BONE_LIMIT","jointOffset","JOINT","weightOffset","WEIGHT","jointSource","inverseSource","INV_BIND_MATRIX","jointCount","vertexSkinData","skinIndex","weightId","skinWeight","weight","descending","d","bindMatrix","Matrix4","identity","boneInverse","getController","parseImage","init_from","images","buildImage","getImage","parseEffect","profile","parseEffectProfileCOMMON","effects","surfaces","parseEffectNewparam","technique","parseEffectTechnique","extra","parseEffectExtra","parseEffectSurface","parseEffectSampler","source","type","parameters","parseEffectParameters","parseEffectParameter","opaque","parseEffectParameterTexture","parseEffectParameterTextureExtra","parseEffectParameterTextureExtraTechnique","toUpperCase","parseEffectExtraTechnique","buildEffect","getEffect","parseMaterial","materials","getTextureLoader","image","extension","slice","lastIndexOf","toLowerCase","tgaLoader","textureLoader","buildMaterial","effect","material","MeshPhongMaterial","MeshLambertMaterial","MeshBasicMaterial","getTexture","textureObject","surface","texture","wrapS","wrapU","RepeatWrapping","ClampToEdgeWrapping","wrapT","wrapV","set","offsetU","offsetV","repeat","repeatU","repeatV","parameter","color","map","specular","specularMap","normalMap","lightMap","float","shininess","emissive","emissiveMap","transparent","transparency","opacity","double_sided","side","DoubleSide","getMaterial","parseCamera","optics","parseCameraOptics","cameras","parseCameraTechnique","parseCameraParameters","buildCamera","camera","PerspectiveCamera","yfov","aspect_ratio","znear","zfar","ymag","xmag","aspectRatio","OrthographicCamera","getCamera","parseLight","parseLightTechnique","lights","parseLightParameters","Color","falloffAngle","f","distance","Math","sqrt","buildLight","light","DirectionalLight","PointLight","SpotLight","AmbientLight","copy","getLight","parseGeometry","vertices","primitives","mesh","parseGeometryVertices","parseGeometryPrimitive","accessor","primitive","hasUV","inputname","max","p","groupPrimitives","checkUVCoordinates","uvsNeedsFix","buildGeometry","groupedPrimitives","primitiveType","buildGeometryType","normal","uv","uv2","BufferGeometry","materialKeys","g","vc","addGroup","input","prevLength","buildGeometryData","addAttribute","Float32BufferAttribute","pushVector","sourceStride","sourceArray","c","k","kl","getGeometry","parseKinematicsModel","links","parseKinematicsTechniqueCommon","kinematicsModels","buildKinematicsModel","getKinematicsModel","parseKinematicsJoint","parseKinematicsLink","parseKinematicsJointParameter","axis","limits","min","static","zeroPosition","middlePosition","attachments","parseKinematicsAttachment","parseKinematicsTransform","joint","pop","obj","angle","MathUtils","degToRad","parsePhysicsModel","rigidBodies","parsePhysicsRigidBody","physicsModels","parsePhysicsTechniqueCommon","inertia","mass","parseKinematicsScene","bindJointAxis","parseKinematicsBindJointAxis","kinematicsScenes","param","tmpJointIndex","jointIndex","substr","buildKinematicsScene","getKinematicsScene","setupKinematics","kinematicsModelId","kinematicsSceneId","visualSceneId","visualScenes","kinematicsModel","kinematicsScene","visualScene","getVisualScene","jointMap","targetElement","collada","querySelector","parentVisualElement","parentElement","connect","visualElement","visualElementName","traverse","buildTransformList","m0","kinematics","getJointValue","jointData","setJointValue","multiply","makeRotationAxis","makeTranslation","vector","prepareNodes","element","setAttribute","parseNode","instanceCameras","instanceControllers","instanceLights","instanceGeometries","instanceNodes","parseNodeInstance","hasNode","skeletons","instances","instance","symbol","buildSkeleton","boneData","sortedBoneData","skeleton","root","buildBoneHierarchy","hasVisualScene","children","error","bone","processed","bones","boneInverses","Skeleton","isBone","buildNode","objects","instanceCamera","controller","newObjects","buildObjects","isSkinnedMesh","bind","normalizeSkinWeights","instanceLight","Bone","Group","add","fallbackMaterial","resolveMaterialBinding","instanceMaterials","LineBasicMaterial","skinning","attributes","LineSegments","Line","SkinnedMesh","Mesh","parseVisualScene","buildVisualScene","group","parseScene","setupAnimations","scene","Scene","DOMParser","parseFromString","version","asset","TextureLoader","TGALoader","setFromEuler","Euler","PI","multiplyScalar"],"sources":["C:/UsersFolders/Polina/РЭУ/Graph/view/node_modules/aframe-extras/lib/ColladaLoader.js"],"sourcesContent":["/**\n * @author mrdoob / http://mrdoob.com/\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nmodule.exports = THREE.ColladaLoader = function ( manager ) {\n\n  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nTHREE.ColladaLoader.prototype = {\n\n  constructor: THREE.ColladaLoader,\n\n  crossOrigin: 'anonymous',\n\n  load: function ( url, onLoad, onProgress, onError ) {\n\n    var scope = this;\n\n    var path = ( scope.path === undefined ) ? THREE.LoaderUtils.extractUrlBase( url ) : scope.path;\n\n    var loader = new THREE.FileLoader( scope.manager );\n    loader.setPath( scope.path );\n    loader.load( url, function ( text ) {\n\n      onLoad( scope.parse( text, path ) );\n\n    }, onProgress, onError );\n\n  },\n\n  setPath: function ( value ) {\n\n    this.path = value;\n    return this;\n\n  },\n\n  setResourcePath: function ( value ) {\n\n    this.resourcePath = value;\n    return this;\n\n  },\n\n  options: {\n\n    set convertUpAxis( value ) {\n\n      console.warn( 'THREE.ColladaLoader: options.convertUpAxis() has been removed. Up axis is converted automatically.' );\n\n    }\n\n  },\n\n  setCrossOrigin: function ( value ) {\n\n    this.crossOrigin = value;\n    return this;\n\n  },\n\n  parse: function ( text, path ) {\n\n    function getElementsByTagName( xml, name ) {\n\n      // Non recursive xml.getElementsByTagName() ...\n\n      var array = [];\n      var childNodes = xml.childNodes;\n\n      for ( var i = 0, l = childNodes.length; i < l; i ++ ) {\n\n        var child = childNodes[ i ];\n\n        if ( child.nodeName === name ) {\n\n          array.push( child );\n\n        }\n\n      }\n\n      return array;\n\n    }\n\n    function parseStrings( text ) {\n\n      if ( text.length === 0 ) return [];\n\n      var parts = text.trim().split( /\\s+/ );\n      var array = new Array( parts.length );\n\n      for ( var i = 0, l = parts.length; i < l; i ++ ) {\n\n        array[ i ] = parts[ i ];\n\n      }\n\n      return array;\n\n    }\n\n    function parseFloats( text ) {\n\n      if ( text.length === 0 ) return [];\n\n      var parts = text.trim().split( /\\s+/ );\n      var array = new Array( parts.length );\n\n      for ( var i = 0, l = parts.length; i < l; i ++ ) {\n\n        array[ i ] = parseFloat( parts[ i ] );\n\n      }\n\n      return array;\n\n    }\n\n    function parseInts( text ) {\n\n      if ( text.length === 0 ) return [];\n\n      var parts = text.trim().split( /\\s+/ );\n      var array = new Array( parts.length );\n\n      for ( var i = 0, l = parts.length; i < l; i ++ ) {\n\n        array[ i ] = parseInt( parts[ i ] );\n\n      }\n\n      return array;\n\n    }\n\n    function parseId( text ) {\n\n      return text.substring( 1 );\n\n    }\n\n    function generateId() {\n\n      return 'three_default_' + ( count ++ );\n\n    }\n\n    function isEmpty( object ) {\n\n      return Object.keys( object ).length === 0;\n\n    }\n\n    // asset\n\n    function parseAsset( xml ) {\n\n      return {\n        unit: parseAssetUnit( getElementsByTagName( xml, 'unit' )[ 0 ] ),\n        upAxis: parseAssetUpAxis( getElementsByTagName( xml, 'up_axis' )[ 0 ] )\n      };\n\n    }\n\n    function parseAssetUnit( xml ) {\n\n      if ( ( xml !== undefined ) && ( xml.hasAttribute( 'meter' ) === true ) ) {\n\n        return parseFloat( xml.getAttribute( 'meter' ) );\n\n      } else {\n\n        return 1; // default 1 meter\n\n      }\n\n    }\n\n    function parseAssetUpAxis( xml ) {\n\n      return xml !== undefined ? xml.textContent : 'Y_UP';\n\n    }\n\n    // library\n\n    function parseLibrary( xml, libraryName, nodeName, parser ) {\n\n      var library = getElementsByTagName( xml, libraryName )[ 0 ];\n\n      if ( library !== undefined ) {\n\n        var elements = getElementsByTagName( library, nodeName );\n\n        for ( var i = 0; i < elements.length; i ++ ) {\n\n          parser( elements[ i ] );\n\n        }\n\n      }\n\n    }\n\n    function buildLibrary( data, builder ) {\n\n      for ( var name in data ) {\n\n        var object = data[ name ];\n        object.build = builder( data[ name ] );\n\n      }\n\n    }\n\n    // get\n\n    function getBuild( data, builder ) {\n\n      if ( data.build !== undefined ) return data.build;\n\n      data.build = builder( data );\n\n      return data.build;\n\n    }\n\n    // animation\n\n    function parseAnimation( xml ) {\n\n      var data = {\n        sources: {},\n        samplers: {},\n        channels: {}\n      };\n\n      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        var id;\n\n        switch ( child.nodeName ) {\n\n          case 'source':\n            id = child.getAttribute( 'id' );\n            data.sources[ id ] = parseSource( child );\n            break;\n\n          case 'sampler':\n            id = child.getAttribute( 'id' );\n            data.samplers[ id ] = parseAnimationSampler( child );\n            break;\n\n          case 'channel':\n            id = child.getAttribute( 'target' );\n            data.channels[ id ] = parseAnimationChannel( child );\n            break;\n\n          default:\n            console.log( child );\n\n        }\n\n      }\n\n      library.animations[ xml.getAttribute( 'id' ) ] = data;\n\n    }\n\n    function parseAnimationSampler( xml ) {\n\n      var data = {\n        inputs: {},\n      };\n\n      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'input':\n            var id = parseId( child.getAttribute( 'source' ) );\n            var semantic = child.getAttribute( 'semantic' );\n            data.inputs[ semantic ] = id;\n            break;\n\n        }\n\n      }\n\n      return data;\n\n    }\n\n    function parseAnimationChannel( xml ) {\n\n      var data = {};\n\n      var target = xml.getAttribute( 'target' );\n\n      // parsing SID Addressing Syntax\n\n      var parts = target.split( '/' );\n\n      var id = parts.shift();\n      var sid = parts.shift();\n\n      // check selection syntax\n\n      var arraySyntax = ( sid.indexOf( '(' ) !== - 1 );\n      var memberSyntax = ( sid.indexOf( '.' ) !== - 1 );\n\n      if ( memberSyntax ) {\n\n        //  member selection access\n\n        parts = sid.split( '.' );\n        sid = parts.shift();\n        data.member = parts.shift();\n\n      } else if ( arraySyntax ) {\n\n        // array-access syntax. can be used to express fields in one-dimensional vectors or two-dimensional matrices.\n\n        var indices = sid.split( '(' );\n        sid = indices.shift();\n\n        for ( var i = 0; i < indices.length; i ++ ) {\n\n          indices[ i ] = parseInt( indices[ i ].replace( /\\)/, '' ) );\n\n        }\n\n        data.indices = indices;\n\n      }\n\n      data.id = id;\n      data.sid = sid;\n\n      data.arraySyntax = arraySyntax;\n      data.memberSyntax = memberSyntax;\n\n      data.sampler = parseId( xml.getAttribute( 'source' ) );\n\n      return data;\n\n    }\n\n    function buildAnimation( data ) {\n\n      var tracks = [];\n\n      var channels = data.channels;\n      var samplers = data.samplers;\n      var sources = data.sources;\n\n      for ( var target in channels ) {\n\n        if ( channels.hasOwnProperty( target ) ) {\n\n          var channel = channels[ target ];\n          var sampler = samplers[ channel.sampler ];\n\n          var inputId = sampler.inputs.INPUT;\n          var outputId = sampler.inputs.OUTPUT;\n\n          var inputSource = sources[ inputId ];\n          var outputSource = sources[ outputId ];\n\n          var animation = buildAnimationChannel( channel, inputSource, outputSource );\n\n          createKeyframeTracks( animation, tracks );\n\n        }\n\n      }\n\n      return tracks;\n\n    }\n\n    function getAnimation( id ) {\n\n      return getBuild( library.animations[ id ], buildAnimation );\n\n    }\n\n    function buildAnimationChannel( channel, inputSource, outputSource ) {\n\n      var node = library.nodes[ channel.id ];\n      var object3D = getNode( node.id );\n\n      var transform = node.transforms[ channel.sid ];\n      var defaultMatrix = node.matrix.clone().transpose();\n\n      var time, stride;\n      var i, il, j, jl;\n\n      var data = {};\n\n      // the collada spec allows the animation of data in various ways.\n      // depending on the transform type (matrix, translate, rotate, scale), we execute different logic\n\n      switch ( transform ) {\n\n        case 'matrix':\n\n          for ( i = 0, il = inputSource.array.length; i < il; i ++ ) {\n\n            time = inputSource.array[ i ];\n            stride = i * outputSource.stride;\n\n            if ( data[ time ] === undefined ) data[ time ] = {};\n\n            if ( channel.arraySyntax === true ) {\n\n              var value = outputSource.array[ stride ];\n              var index = channel.indices[ 0 ] + 4 * channel.indices[ 1 ];\n\n              data[ time ][ index ] = value;\n\n            } else {\n\n              for ( j = 0, jl = outputSource.stride; j < jl; j ++ ) {\n\n                data[ time ][ j ] = outputSource.array[ stride + j ];\n\n              }\n\n            }\n\n          }\n\n          break;\n\n        case 'translate':\n          console.warn( 'THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform );\n          break;\n\n        case 'rotate':\n          console.warn( 'THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform );\n          break;\n\n        case 'scale':\n          console.warn( 'THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform );\n          break;\n\n      }\n\n      var keyframes = prepareAnimationData( data, defaultMatrix );\n\n      var animation = {\n        name: object3D.uuid,\n        keyframes: keyframes\n      };\n\n      return animation;\n\n    }\n\n    function prepareAnimationData( data, defaultMatrix ) {\n\n      var keyframes = [];\n\n      // transfer data into a sortable array\n\n      for ( var time in data ) {\n\n        keyframes.push( { time: parseFloat( time ), value: data[ time ] } );\n\n      }\n\n      // ensure keyframes are sorted by time\n\n      keyframes.sort( ascending );\n\n      // now we clean up all animation data, so we can use them for keyframe tracks\n\n      for ( var i = 0; i < 16; i ++ ) {\n\n        transformAnimationData( keyframes, i, defaultMatrix.elements[ i ] );\n\n      }\n\n      return keyframes;\n\n      // array sort function\n\n      function ascending( a, b ) {\n\n        return a.time - b.time;\n\n      }\n\n    }\n\n    var position = new THREE.Vector3();\n    var scale = new THREE.Vector3();\n    var quaternion = new THREE.Quaternion();\n\n    function createKeyframeTracks( animation, tracks ) {\n\n      var keyframes = animation.keyframes;\n      var name = animation.name;\n\n      var times = [];\n      var positionData = [];\n      var quaternionData = [];\n      var scaleData = [];\n\n      for ( var i = 0, l = keyframes.length; i < l; i ++ ) {\n\n        var keyframe = keyframes[ i ];\n\n        var time = keyframe.time;\n        var value = keyframe.value;\n\n        matrix.fromArray( value ).transpose();\n        matrix.decompose( position, quaternion, scale );\n\n        times.push( time );\n        positionData.push( position.x, position.y, position.z );\n        quaternionData.push( quaternion.x, quaternion.y, quaternion.z, quaternion.w );\n        scaleData.push( scale.x, scale.y, scale.z );\n\n      }\n\n      if ( positionData.length > 0 ) tracks.push( new THREE.VectorKeyframeTrack( name + '.position', times, positionData ) );\n      if ( quaternionData.length > 0 ) tracks.push( new THREE.QuaternionKeyframeTrack( name + '.quaternion', times, quaternionData ) );\n      if ( scaleData.length > 0 ) tracks.push( new THREE.VectorKeyframeTrack( name + '.scale', times, scaleData ) );\n\n      return tracks;\n\n    }\n\n    function transformAnimationData( keyframes, property, defaultValue ) {\n\n      var keyframe;\n\n      var empty = true;\n      var i, l;\n\n      // check, if values of a property are missing in our keyframes\n\n      for ( i = 0, l = keyframes.length; i < l; i ++ ) {\n\n        keyframe = keyframes[ i ];\n\n        if ( keyframe.value[ property ] === undefined ) {\n\n          keyframe.value[ property ] = null; // mark as missing\n\n        } else {\n\n          empty = false;\n\n        }\n\n      }\n\n      if ( empty === true ) {\n\n        // no values at all, so we set a default value\n\n        for ( i = 0, l = keyframes.length; i < l; i ++ ) {\n\n          keyframe = keyframes[ i ];\n\n          keyframe.value[ property ] = defaultValue;\n\n        }\n\n      } else {\n\n        // filling gaps\n\n        createMissingKeyframes( keyframes, property );\n\n      }\n\n    }\n\n    function createMissingKeyframes( keyframes, property ) {\n\n      var prev, next;\n\n      for ( var i = 0, l = keyframes.length; i < l; i ++ ) {\n\n        var keyframe = keyframes[ i ];\n\n        if ( keyframe.value[ property ] === null ) {\n\n          prev = getPrev( keyframes, i, property );\n          next = getNext( keyframes, i, property );\n\n          if ( prev === null ) {\n\n            keyframe.value[ property ] = next.value[ property ];\n            continue;\n\n          }\n\n          if ( next === null ) {\n\n            keyframe.value[ property ] = prev.value[ property ];\n            continue;\n\n          }\n\n          interpolate( keyframe, prev, next, property );\n\n        }\n\n      }\n\n    }\n\n    function getPrev( keyframes, i, property ) {\n\n      while ( i >= 0 ) {\n\n        var keyframe = keyframes[ i ];\n\n        if ( keyframe.value[ property ] !== null ) return keyframe;\n\n        i --;\n\n      }\n\n      return null;\n\n    }\n\n    function getNext( keyframes, i, property ) {\n\n      while ( i < keyframes.length ) {\n\n        var keyframe = keyframes[ i ];\n\n        if ( keyframe.value[ property ] !== null ) return keyframe;\n\n        i ++;\n\n      }\n\n      return null;\n\n    }\n\n    function interpolate( key, prev, next, property ) {\n\n      if ( ( next.time - prev.time ) === 0 ) {\n\n        key.value[ property ] = prev.value[ property ];\n        return;\n\n      }\n\n      key.value[ property ] = ( ( key.time - prev.time ) * ( next.value[ property ] - prev.value[ property ] ) / ( next.time - prev.time ) ) + prev.value[ property ];\n\n    }\n\n    // animation clips\n\n    function parseAnimationClip( xml ) {\n\n      var data = {\n        name: xml.getAttribute( 'id' ) || 'default',\n        start: parseFloat( xml.getAttribute( 'start' ) || 0 ),\n        end: parseFloat( xml.getAttribute( 'end' ) || 0 ),\n        animations: []\n      };\n\n      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'instance_animation':\n            data.animations.push( parseId( child.getAttribute( 'url' ) ) );\n            break;\n\n        }\n\n      }\n\n      library.clips[ xml.getAttribute( 'id' ) ] = data;\n\n    }\n\n    function buildAnimationClip( data ) {\n\n      var tracks = [];\n\n      var name = data.name;\n      var duration = ( data.end - data.start ) || - 1;\n      var animations = data.animations;\n\n      for ( var i = 0, il = animations.length; i < il; i ++ ) {\n\n        var animationTracks = getAnimation( animations[ i ] );\n\n        for ( var j = 0, jl = animationTracks.length; j < jl; j ++ ) {\n\n          tracks.push( animationTracks[ j ] );\n\n        }\n\n      }\n\n      return new THREE.AnimationClip( name, duration, tracks );\n\n    }\n\n    function getAnimationClip( id ) {\n\n      return getBuild( library.clips[ id ], buildAnimationClip );\n\n    }\n\n    // controller\n\n    function parseController( xml ) {\n\n      var data = {};\n\n      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'skin':\n            // there is exactly one skin per controller\n            data.id = parseId( child.getAttribute( 'source' ) );\n            data.skin = parseSkin( child );\n            break;\n\n          case 'morph':\n            data.id = parseId( child.getAttribute( 'source' ) );\n            console.warn( 'THREE.ColladaLoader: Morph target animation not supported yet.' );\n            break;\n\n        }\n\n      }\n\n      library.controllers[ xml.getAttribute( 'id' ) ] = data;\n\n    }\n\n    function parseSkin( xml ) {\n\n      var data = {\n        sources: {}\n      };\n\n      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'bind_shape_matrix':\n            data.bindShapeMatrix = parseFloats( child.textContent );\n            break;\n\n          case 'source':\n            var id = child.getAttribute( 'id' );\n            data.sources[ id ] = parseSource( child );\n            break;\n\n          case 'joints':\n            data.joints = parseJoints( child );\n            break;\n\n          case 'vertex_weights':\n            data.vertexWeights = parseVertexWeights( child );\n            break;\n\n        }\n\n      }\n\n      return data;\n\n    }\n\n    function parseJoints( xml ) {\n\n      var data = {\n        inputs: {}\n      };\n\n      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'input':\n            var semantic = child.getAttribute( 'semantic' );\n            var id = parseId( child.getAttribute( 'source' ) );\n            data.inputs[ semantic ] = id;\n            break;\n\n        }\n\n      }\n\n      return data;\n\n    }\n\n    function parseVertexWeights( xml ) {\n\n      var data = {\n        inputs: {}\n      };\n\n      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'input':\n            var semantic = child.getAttribute( 'semantic' );\n            var id = parseId( child.getAttribute( 'source' ) );\n            var offset = parseInt( child.getAttribute( 'offset' ) );\n            data.inputs[ semantic ] = { id: id, offset: offset };\n            break;\n\n          case 'vcount':\n            data.vcount = parseInts( child.textContent );\n            break;\n\n          case 'v':\n            data.v = parseInts( child.textContent );\n            break;\n\n        }\n\n      }\n\n      return data;\n\n    }\n\n    function buildController( data ) {\n\n      var build = {\n        id: data.id\n      };\n\n      var geometry = library.geometries[ build.id ];\n\n      if ( data.skin !== undefined ) {\n\n        build.skin = buildSkin( data.skin );\n\n        // we enhance the 'sources' property of the corresponding geometry with our skin data\n\n        geometry.sources.skinIndices = build.skin.indices;\n        geometry.sources.skinWeights = build.skin.weights;\n\n      }\n\n      return build;\n\n    }\n\n    function buildSkin( data ) {\n\n      var BONE_LIMIT = 4;\n\n      var build = {\n        joints: [], // this must be an array to preserve the joint order\n        indices: {\n          array: [],\n          stride: BONE_LIMIT\n        },\n        weights: {\n          array: [],\n          stride: BONE_LIMIT\n        }\n      };\n\n      var sources = data.sources;\n      var vertexWeights = data.vertexWeights;\n\n      var vcount = vertexWeights.vcount;\n      var v = vertexWeights.v;\n      var jointOffset = vertexWeights.inputs.JOINT.offset;\n      var weightOffset = vertexWeights.inputs.WEIGHT.offset;\n\n      var jointSource = data.sources[ data.joints.inputs.JOINT ];\n      var inverseSource = data.sources[ data.joints.inputs.INV_BIND_MATRIX ];\n\n      var weights = sources[ vertexWeights.inputs.WEIGHT.id ].array;\n      var stride = 0;\n\n      var i, j, l;\n\n      // procces skin data for each vertex\n\n      for ( i = 0, l = vcount.length; i < l; i ++ ) {\n\n        var jointCount = vcount[ i ]; // this is the amount of joints that affect a single vertex\n        var vertexSkinData = [];\n\n        for ( j = 0; j < jointCount; j ++ ) {\n\n          var skinIndex = v[ stride + jointOffset ];\n          var weightId = v[ stride + weightOffset ];\n          var skinWeight = weights[ weightId ];\n\n          vertexSkinData.push( { index: skinIndex, weight: skinWeight } );\n\n          stride += 2;\n\n        }\n\n        // we sort the joints in descending order based on the weights.\n        // this ensures, we only procced the most important joints of the vertex\n\n        vertexSkinData.sort( descending );\n\n        // now we provide for each vertex a set of four index and weight values.\n        // the order of the skin data matches the order of vertices\n\n        for ( j = 0; j < BONE_LIMIT; j ++ ) {\n\n          var d = vertexSkinData[ j ];\n\n          if ( d !== undefined ) {\n\n            build.indices.array.push( d.index );\n            build.weights.array.push( d.weight );\n\n          } else {\n\n            build.indices.array.push( 0 );\n            build.weights.array.push( 0 );\n\n          }\n\n        }\n\n      }\n\n      // setup bind matrix\n\n      if ( data.bindShapeMatrix ) {\n\n        build.bindMatrix = new THREE.Matrix4().fromArray( data.bindShapeMatrix ).transpose();\n\n      } else {\n\n        build.bindMatrix = new THREE.Matrix4().identity();\n\n      }\n\n      // process bones and inverse bind matrix data\n\n      for ( i = 0, l = jointSource.array.length; i < l; i ++ ) {\n\n        var name = jointSource.array[ i ];\n        var boneInverse = new THREE.Matrix4().fromArray( inverseSource.array, i * inverseSource.stride ).transpose();\n\n        build.joints.push( { name: name, boneInverse: boneInverse } );\n\n      }\n\n      return build;\n\n      // array sort function\n\n      function descending( a, b ) {\n\n        return b.weight - a.weight;\n\n      }\n\n    }\n\n    function getController( id ) {\n\n      return getBuild( library.controllers[ id ], buildController );\n\n    }\n\n    // image\n\n    function parseImage( xml ) {\n\n      var data = {\n        init_from: getElementsByTagName( xml, 'init_from' )[ 0 ].textContent\n      };\n\n      library.images[ xml.getAttribute( 'id' ) ] = data;\n\n    }\n\n    function buildImage( data ) {\n\n      if ( data.build !== undefined ) return data.build;\n\n      return data.init_from;\n\n    }\n\n    function getImage( id ) {\n\n      var data = library.images[ id ];\n\n      if ( data !== undefined ) {\n\n        return getBuild( data, buildImage );\n\n      }\n\n      console.warn( 'THREE.ColladaLoader: Couldn\\'t find image with ID:', id );\n\n      return null;\n\n    }\n\n    // effect\n\n    function parseEffect( xml ) {\n\n      var data = {};\n\n      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'profile_COMMON':\n            data.profile = parseEffectProfileCOMMON( child );\n            break;\n\n        }\n\n      }\n\n      library.effects[ xml.getAttribute( 'id' ) ] = data;\n\n    }\n\n    function parseEffectProfileCOMMON( xml ) {\n\n      var data = {\n        surfaces: {},\n        samplers: {}\n      };\n\n      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'newparam':\n            parseEffectNewparam( child, data );\n            break;\n\n          case 'technique':\n            data.technique = parseEffectTechnique( child );\n            break;\n\n          case 'extra':\n            data.extra = parseEffectExtra( child );\n            break;\n\n        }\n\n      }\n\n      return data;\n\n    }\n\n    function parseEffectNewparam( xml, data ) {\n\n      var sid = xml.getAttribute( 'sid' );\n\n      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'surface':\n            data.surfaces[ sid ] = parseEffectSurface( child );\n            break;\n\n          case 'sampler2D':\n            data.samplers[ sid ] = parseEffectSampler( child );\n            break;\n\n        }\n\n      }\n\n    }\n\n    function parseEffectSurface( xml ) {\n\n      var data = {};\n\n      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'init_from':\n            data.init_from = child.textContent;\n            break;\n\n        }\n\n      }\n\n      return data;\n\n    }\n\n    function parseEffectSampler( xml ) {\n\n      var data = {};\n\n      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'source':\n            data.source = child.textContent;\n            break;\n\n        }\n\n      }\n\n      return data;\n\n    }\n\n    function parseEffectTechnique( xml ) {\n\n      var data = {};\n\n      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'constant':\n          case 'lambert':\n          case 'blinn':\n          case 'phong':\n            data.type = child.nodeName;\n            data.parameters = parseEffectParameters( child );\n            break;\n\n        }\n\n      }\n\n      return data;\n\n    }\n\n    function parseEffectParameters( xml ) {\n\n      var data = {};\n\n      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'emission':\n          case 'diffuse':\n          case 'specular':\n          case 'bump':\n          case 'ambient':\n          case 'shininess':\n          case 'transparency':\n            data[ child.nodeName ] = parseEffectParameter( child );\n            break;\n          case 'transparent':\n            data[ child.nodeName ] = {\n              opaque: child.getAttribute( 'opaque' ),\n              data: parseEffectParameter( child )\n            };\n            break;\n\n        }\n\n      }\n\n      return data;\n\n    }\n\n    function parseEffectParameter( xml ) {\n\n      var data = {};\n\n      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'color':\n            data[ child.nodeName ] = parseFloats( child.textContent );\n            break;\n\n          case 'float':\n            data[ child.nodeName ] = parseFloat( child.textContent );\n            break;\n\n          case 'texture':\n            data[ child.nodeName ] = { id: child.getAttribute( 'texture' ), extra: parseEffectParameterTexture( child ) };\n            break;\n\n        }\n\n      }\n\n      return data;\n\n    }\n\n    function parseEffectParameterTexture( xml ) {\n\n      var data = {\n        technique: {}\n      };\n\n      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'extra':\n            parseEffectParameterTextureExtra( child, data );\n            break;\n\n        }\n\n      }\n\n      return data;\n\n    }\n\n    function parseEffectParameterTextureExtra( xml, data ) {\n\n      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'technique':\n            parseEffectParameterTextureExtraTechnique( child, data );\n            break;\n\n        }\n\n      }\n\n    }\n\n    function parseEffectParameterTextureExtraTechnique( xml, data ) {\n\n      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'repeatU':\n          case 'repeatV':\n          case 'offsetU':\n          case 'offsetV':\n            data.technique[ child.nodeName ] = parseFloat( child.textContent );\n            break;\n\n          case 'wrapU':\n          case 'wrapV':\n\n            // some files have values for wrapU/wrapV which become NaN via parseInt\n\n            if ( child.textContent.toUpperCase() === 'TRUE' ) {\n\n              data.technique[ child.nodeName ] = 1;\n\n            } else if ( child.textContent.toUpperCase() === 'FALSE' ) {\n\n              data.technique[ child.nodeName ] = 0;\n\n            } else {\n\n              data.technique[ child.nodeName ] = parseInt( child.textContent );\n\n            }\n\n            break;\n\n        }\n\n      }\n\n    }\n\n    function parseEffectExtra( xml ) {\n\n      var data = {};\n\n      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'technique':\n            data.technique = parseEffectExtraTechnique( child );\n            break;\n\n        }\n\n      }\n\n      return data;\n\n    }\n\n    function parseEffectExtraTechnique( xml ) {\n\n      var data = {};\n\n      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'double_sided':\n            data[ child.nodeName ] = parseInt( child.textContent );\n            break;\n\n        }\n\n      }\n\n      return data;\n\n    }\n\n    function buildEffect( data ) {\n\n      return data;\n\n    }\n\n    function getEffect( id ) {\n\n      return getBuild( library.effects[ id ], buildEffect );\n\n    }\n\n    // material\n\n    function parseMaterial( xml ) {\n\n      var data = {\n        name: xml.getAttribute( 'name' )\n      };\n\n      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'instance_effect':\n            data.url = parseId( child.getAttribute( 'url' ) );\n            break;\n\n        }\n\n      }\n\n      library.materials[ xml.getAttribute( 'id' ) ] = data;\n\n    }\n\n    function getTextureLoader( image ) {\n\n      var loader;\n\n      var extension = image.slice( ( image.lastIndexOf( '.' ) - 1 >>> 0 ) + 2 ); // http://www.jstips.co/en/javascript/get-file-extension/\n      extension = extension.toLowerCase();\n\n      switch ( extension ) {\n\n        case 'tga':\n          loader = tgaLoader;\n          break;\n\n        default:\n          loader = textureLoader;\n\n      }\n\n      return loader;\n\n    }\n\n    function buildMaterial( data ) {\n\n      var effect = getEffect( data.url );\n      var technique = effect.profile.technique;\n      var extra = effect.profile.extra;\n\n      var material;\n\n      switch ( technique.type ) {\n\n        case 'phong':\n        case 'blinn':\n          material = new THREE.MeshPhongMaterial();\n          break;\n\n        case 'lambert':\n          material = new THREE.MeshLambertMaterial();\n          break;\n\n        default:\n          material = new THREE.MeshBasicMaterial();\n          break;\n\n      }\n\n      material.name = data.name;\n\n      function getTexture( textureObject ) {\n\n        var sampler = effect.profile.samplers[ textureObject.id ];\n        var image = null;\n\n        // get image\n\n        if ( sampler !== undefined ) {\n\n          var surface = effect.profile.surfaces[ sampler.source ];\n          image = getImage( surface.init_from );\n\n        } else {\n\n          console.warn( 'THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).' );\n          image = getImage( textureObject.id );\n\n        }\n\n        // create texture if image is avaiable\n\n        if ( image !== null ) {\n\n          var loader = getTextureLoader( image );\n\n          if ( loader !== undefined ) {\n\n            var texture = loader.load( image );\n\n            var extra = textureObject.extra;\n\n            if ( extra !== undefined && extra.technique !== undefined && isEmpty( extra.technique ) === false ) {\n\n              var technique = extra.technique;\n\n              texture.wrapS = technique.wrapU ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n              texture.wrapT = technique.wrapV ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n\n              texture.offset.set( technique.offsetU || 0, technique.offsetV || 0 );\n              texture.repeat.set( technique.repeatU || 1, technique.repeatV || 1 );\n\n            } else {\n\n              texture.wrapS = THREE.RepeatWrapping;\n              texture.wrapT = THREE.RepeatWrapping;\n\n            }\n\n            return texture;\n\n          } else {\n\n            console.warn( 'THREE.ColladaLoader: Loader for texture %s not found.', image );\n\n            return null;\n\n          }\n\n        } else {\n\n          console.warn( 'THREE.ColladaLoader: Couldn\\'t create texture with ID:', textureObject.id );\n\n          return null;\n\n        }\n\n      }\n\n      var parameters = technique.parameters;\n\n      for ( var key in parameters ) {\n\n        var parameter = parameters[ key ];\n\n        switch ( key ) {\n\n          case 'diffuse':\n            if ( parameter.color ) material.color.fromArray( parameter.color );\n            if ( parameter.texture ) material.map = getTexture( parameter.texture );\n            break;\n          case 'specular':\n            if ( parameter.color && material.specular ) material.specular.fromArray( parameter.color );\n            if ( parameter.texture ) material.specularMap = getTexture( parameter.texture );\n            break;\n          case 'bump':\n            if ( parameter.texture ) material.normalMap = getTexture( parameter.texture );\n            break;\n          case 'ambient':\n            if ( parameter.texture ) material.lightMap = getTexture( parameter.texture );\n            break;\n          case 'shininess':\n            if ( parameter.float && material.shininess ) material.shininess = parameter.float;\n            break;\n          case 'emission':\n            if ( parameter.color && material.emissive ) material.emissive.fromArray( parameter.color );\n            if ( parameter.texture ) material.emissiveMap = getTexture( parameter.texture );\n            break;\n\n        }\n\n      }\n\n      //\n\n      var transparent = parameters[ 'transparent' ];\n      var transparency = parameters[ 'transparency' ];\n\n      // <transparency> does not exist but <transparent>\n\n      if ( transparency === undefined && transparent ) {\n\n        transparency = {\n          float: 1\n        };\n\n      }\n\n      // <transparent> does not exist but <transparency>\n\n      if ( transparent === undefined && transparency ) {\n\n        transparent = {\n          opaque: 'A_ONE',\n          data: {\n            color: [ 1, 1, 1, 1 ]\n          } };\n\n      }\n\n      if ( transparent && transparency ) {\n\n        // handle case if a texture exists but no color\n\n        if ( transparent.data.texture ) {\n\n          // we do not set an alpha map (see #13792)\n\n          material.transparent = true;\n\n        } else {\n\n          var color = transparent.data.color;\n\n          switch ( transparent.opaque ) {\n\n            case 'A_ONE':\n              material.opacity = color[ 3 ] * transparency.float;\n              break;\n            case 'RGB_ZERO':\n              material.opacity = 1 - ( color[ 0 ] * transparency.float );\n              break;\n            case 'A_ZERO':\n              material.opacity = 1 - ( color[ 3 ] * transparency.float );\n              break;\n            case 'RGB_ONE':\n              material.opacity = color[ 0 ] * transparency.float;\n              break;\n            default:\n              console.warn( 'THREE.ColladaLoader: Invalid opaque type \"%s\" of transparent tag.', transparent.opaque );\n\n          }\n\n          if ( material.opacity < 1 ) material.transparent = true;\n\n        }\n\n      }\n\n      //\n\n      if ( extra !== undefined && extra.technique !== undefined && extra.technique.double_sided === 1 ) {\n\n        material.side = THREE.DoubleSide;\n\n      }\n\n      return material;\n\n    }\n\n    function getMaterial( id ) {\n\n      return getBuild( library.materials[ id ], buildMaterial );\n\n    }\n\n    // camera\n\n    function parseCamera( xml ) {\n\n      var data = {\n        name: xml.getAttribute( 'name' )\n      };\n\n      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'optics':\n            data.optics = parseCameraOptics( child );\n            break;\n\n        }\n\n      }\n\n      library.cameras[ xml.getAttribute( 'id' ) ] = data;\n\n    }\n\n    function parseCameraOptics( xml ) {\n\n      for ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        switch ( child.nodeName ) {\n\n          case 'technique_common':\n            return parseCameraTechnique( child );\n\n        }\n\n      }\n\n      return {};\n\n    }\n\n    function parseCameraTechnique( xml ) {\n\n      var data = {};\n\n      for ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        switch ( child.nodeName ) {\n\n          case 'perspective':\n          case 'orthographic':\n\n            data.technique = child.nodeName;\n            data.parameters = parseCameraParameters( child );\n\n            break;\n\n        }\n\n      }\n\n      return data;\n\n    }\n\n    function parseCameraParameters( xml ) {\n\n      var data = {};\n\n      for ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        switch ( child.nodeName ) {\n\n          case 'xfov':\n          case 'yfov':\n          case 'xmag':\n          case 'ymag':\n          case 'znear':\n          case 'zfar':\n          case 'aspect_ratio':\n            data[ child.nodeName ] = parseFloat( child.textContent );\n            break;\n\n        }\n\n      }\n\n      return data;\n\n    }\n\n    function buildCamera( data ) {\n\n      var camera;\n\n      switch ( data.optics.technique ) {\n\n        case 'perspective':\n          camera = new THREE.PerspectiveCamera(\n            data.optics.parameters.yfov,\n            data.optics.parameters.aspect_ratio,\n            data.optics.parameters.znear,\n            data.optics.parameters.zfar\n          );\n          break;\n\n        case 'orthographic':\n          var ymag = data.optics.parameters.ymag;\n          var xmag = data.optics.parameters.xmag;\n          var aspectRatio = data.optics.parameters.aspect_ratio;\n\n          xmag = ( xmag === undefined ) ? ( ymag * aspectRatio ) : xmag;\n          ymag = ( ymag === undefined ) ? ( xmag / aspectRatio ) : ymag;\n\n          xmag *= 0.5;\n          ymag *= 0.5;\n\n          camera = new THREE.OrthographicCamera(\n            - xmag, xmag, ymag, - ymag, // left, right, top, bottom\n            data.optics.parameters.znear,\n            data.optics.parameters.zfar\n          );\n          break;\n\n        default:\n          camera = new THREE.PerspectiveCamera();\n          break;\n\n      }\n\n      camera.name = data.name;\n\n      return camera;\n\n    }\n\n    function getCamera( id ) {\n\n      var data = library.cameras[ id ];\n\n      if ( data !== undefined ) {\n\n        return getBuild( data, buildCamera );\n\n      }\n\n      console.warn( 'THREE.ColladaLoader: Couldn\\'t find camera with ID:', id );\n\n      return null;\n\n    }\n\n    // light\n\n    function parseLight( xml ) {\n\n      var data = {};\n\n      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'technique_common':\n            data = parseLightTechnique( child );\n            break;\n\n        }\n\n      }\n\n      library.lights[ xml.getAttribute( 'id' ) ] = data;\n\n    }\n\n    function parseLightTechnique( xml ) {\n\n      var data = {};\n\n      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'directional':\n          case 'point':\n          case 'spot':\n          case 'ambient':\n\n            data.technique = child.nodeName;\n            data.parameters = parseLightParameters( child );\n\n        }\n\n      }\n\n      return data;\n\n    }\n\n    function parseLightParameters( xml ) {\n\n      var data = {};\n\n      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'color':\n            var array = parseFloats( child.textContent );\n            data.color = new THREE.Color().fromArray( array );\n            break;\n\n          case 'falloff_angle':\n            data.falloffAngle = parseFloat( child.textContent );\n            break;\n\n          case 'quadratic_attenuation':\n            var f = parseFloat( child.textContent );\n            data.distance = f ? Math.sqrt( 1 / f ) : 0;\n            break;\n\n        }\n\n      }\n\n      return data;\n\n    }\n\n    function buildLight( data ) {\n\n      var light;\n\n      switch ( data.technique ) {\n\n        case 'directional':\n          light = new THREE.DirectionalLight();\n          break;\n\n        case 'point':\n          light = new THREE.PointLight();\n          break;\n\n        case 'spot':\n          light = new THREE.SpotLight();\n          break;\n\n        case 'ambient':\n          light = new THREE.AmbientLight();\n          break;\n\n      }\n\n      if ( data.parameters.color ) light.color.copy( data.parameters.color );\n      if ( data.parameters.distance ) light.distance = data.parameters.distance;\n\n      return light;\n\n    }\n\n    function getLight( id ) {\n\n      var data = library.lights[ id ];\n\n      if ( data !== undefined ) {\n\n        return getBuild( data, buildLight );\n\n      }\n\n      console.warn( 'THREE.ColladaLoader: Couldn\\'t find light with ID:', id );\n\n      return null;\n\n    }\n\n    // geometry\n\n    function parseGeometry( xml ) {\n\n      var data = {\n        name: xml.getAttribute( 'name' ),\n        sources: {},\n        vertices: {},\n        primitives: []\n      };\n\n      var mesh = getElementsByTagName( xml, 'mesh' )[ 0 ];\n\n      // the following tags inside geometry are not supported yet (see https://github.com/mrdoob/three.js/pull/12606): convex_mesh, spline, brep\n      if ( mesh === undefined ) return;\n\n      for ( var i = 0; i < mesh.childNodes.length; i ++ ) {\n\n        var child = mesh.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        var id = child.getAttribute( 'id' );\n\n        switch ( child.nodeName ) {\n\n          case 'source':\n            data.sources[ id ] = parseSource( child );\n            break;\n\n          case 'vertices':\n            // data.sources[ id ] = data.sources[ parseId( getElementsByTagName( child, 'input' )[ 0 ].getAttribute( 'source' ) ) ];\n            data.vertices = parseGeometryVertices( child );\n            break;\n\n          case 'polygons':\n            console.warn( 'THREE.ColladaLoader: Unsupported primitive type: ', child.nodeName );\n            break;\n\n          case 'lines':\n          case 'linestrips':\n          case 'polylist':\n          case 'triangles':\n            data.primitives.push( parseGeometryPrimitive( child ) );\n            break;\n\n          default:\n            console.log( child );\n\n        }\n\n      }\n\n      library.geometries[ xml.getAttribute( 'id' ) ] = data;\n\n    }\n\n    function parseSource( xml ) {\n\n      var data = {\n        array: [],\n        stride: 3\n      };\n\n      for ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'float_array':\n            data.array = parseFloats( child.textContent );\n            break;\n\n          case 'Name_array':\n            data.array = parseStrings( child.textContent );\n            break;\n\n          case 'technique_common':\n            var accessor = getElementsByTagName( child, 'accessor' )[ 0 ];\n\n            if ( accessor !== undefined ) {\n\n              data.stride = parseInt( accessor.getAttribute( 'stride' ) );\n\n            }\n            break;\n\n        }\n\n      }\n\n      return data;\n\n    }\n\n    function parseGeometryVertices( xml ) {\n\n      var data = {};\n\n      for ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        data[ child.getAttribute( 'semantic' ) ] = parseId( child.getAttribute( 'source' ) );\n\n      }\n\n      return data;\n\n    }\n\n    function parseGeometryPrimitive( xml ) {\n\n      var primitive = {\n        type: xml.nodeName,\n        material: xml.getAttribute( 'material' ),\n        count: parseInt( xml.getAttribute( 'count' ) ),\n        inputs: {},\n        stride: 0,\n        hasUV: false\n      };\n\n      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'input':\n            var id = parseId( child.getAttribute( 'source' ) );\n            var semantic = child.getAttribute( 'semantic' );\n            var offset = parseInt( child.getAttribute( 'offset' ) );\n            var set = parseInt( child.getAttribute( 'set' ) );\n            var inputname = ( set > 0 ? semantic + set : semantic );\n            primitive.inputs[ inputname ] = { id: id, offset: offset };\n            primitive.stride = Math.max( primitive.stride, offset + 1 );\n            if ( semantic === 'TEXCOORD' ) primitive.hasUV = true;\n            break;\n\n          case 'vcount':\n            primitive.vcount = parseInts( child.textContent );\n            break;\n\n          case 'p':\n            primitive.p = parseInts( child.textContent );\n            break;\n\n        }\n\n      }\n\n      return primitive;\n\n    }\n\n    function groupPrimitives( primitives ) {\n\n      var build = {};\n\n      for ( var i = 0; i < primitives.length; i ++ ) {\n\n        var primitive = primitives[ i ];\n\n        if ( build[ primitive.type ] === undefined ) build[ primitive.type ] = [];\n\n        build[ primitive.type ].push( primitive );\n\n      }\n\n      return build;\n\n    }\n\n    function checkUVCoordinates( primitives ) {\n\n      var count = 0;\n\n      for ( var i = 0, l = primitives.length; i < l; i ++ ) {\n\n        var primitive = primitives[ i ];\n\n        if ( primitive.hasUV === true ) {\n\n          count ++;\n\n        }\n\n      }\n\n      if ( count > 0 && count < primitives.length ) {\n\n        primitives.uvsNeedsFix = true;\n\n      }\n\n    }\n\n    function buildGeometry( data ) {\n\n      var build = {};\n\n      var sources = data.sources;\n      var vertices = data.vertices;\n      var primitives = data.primitives;\n\n      if ( primitives.length === 0 ) return {};\n\n      // our goal is to create one buffer geometry for a single type of primitives\n      // first, we group all primitives by their type\n\n      var groupedPrimitives = groupPrimitives( primitives );\n\n      for ( var type in groupedPrimitives ) {\n\n        var primitiveType = groupedPrimitives[ type ];\n\n        // second, ensure consistent uv coordinates for each type of primitives (polylist,triangles or lines)\n\n        checkUVCoordinates( primitiveType );\n\n        // third, create a buffer geometry for each type of primitives\n\n        build[ type ] = buildGeometryType( primitiveType, sources, vertices );\n\n      }\n\n      return build;\n\n    }\n\n    function buildGeometryType( primitives, sources, vertices ) {\n\n      var build = {};\n\n      var position = { array: [], stride: 0 };\n      var normal = { array: [], stride: 0 };\n      var uv = { array: [], stride: 0 };\n      var uv2 = { array: [], stride: 0 };\n      var color = { array: [], stride: 0 };\n\n      var skinIndex = { array: [], stride: 4 };\n      var skinWeight = { array: [], stride: 4 };\n\n      var geometry = new THREE.BufferGeometry();\n\n      var materialKeys = [];\n\n      var start = 0;\n\n      for ( var p = 0; p < primitives.length; p ++ ) {\n\n        var primitive = primitives[ p ];\n        var inputs = primitive.inputs;\n\n        // groups\n\n        var count = 0;\n\n        switch ( primitive.type ) {\n\n          case 'lines':\n          case 'linestrips':\n            count = primitive.count * 2;\n            break;\n\n          case 'triangles':\n            count = primitive.count * 3;\n            break;\n\n          case 'polylist':\n\n            for ( var g = 0; g < primitive.count; g ++ ) {\n\n              var vc = primitive.vcount[ g ];\n\n              switch ( vc ) {\n\n                case 3:\n                  count += 3; // single triangle\n                  break;\n\n                case 4:\n                  count += 6; // quad, subdivided into two triangles\n                  break;\n\n                default:\n                  count += ( vc - 2 ) * 3; // polylist with more than four vertices\n                  break;\n\n              }\n\n            }\n\n            break;\n\n          default:\n            console.warn( 'THREE.ColladaLoader: Unknow primitive type:', primitive.type );\n\n        }\n\n        geometry.addGroup( start, count, p );\n        start += count;\n\n        // material\n\n        if ( primitive.material ) {\n\n          materialKeys.push( primitive.material );\n\n        }\n\n        // geometry data\n\n        for ( var name in inputs ) {\n\n          var input = inputs[ name ];\n\n          switch ( name ) {\n\n            case 'VERTEX':\n              for ( var key in vertices ) {\n\n                var id = vertices[ key ];\n\n                switch ( key ) {\n\n                  case 'POSITION':\n                    var prevLength = position.array.length;\n                    buildGeometryData( primitive, sources[ id ], input.offset, position.array );\n                    position.stride = sources[ id ].stride;\n\n                    if ( sources.skinWeights && sources.skinIndices ) {\n\n                      buildGeometryData( primitive, sources.skinIndices, input.offset, skinIndex.array );\n                      buildGeometryData( primitive, sources.skinWeights, input.offset, skinWeight.array );\n\n                    }\n\n                    // see #3803\n\n                    if ( primitive.hasUV === false && primitives.uvsNeedsFix === true ) {\n\n                      var count = ( position.array.length - prevLength ) / position.stride;\n\n                      for ( var i = 0; i < count; i ++ ) {\n\n                        // fill missing uv coordinates\n\n                        uv.array.push( 0, 0 );\n\n                      }\n\n                    }\n                    break;\n\n                  case 'NORMAL':\n                    buildGeometryData( primitive, sources[ id ], input.offset, normal.array );\n                    normal.stride = sources[ id ].stride;\n                    break;\n\n                  case 'COLOR':\n                    buildGeometryData( primitive, sources[ id ], input.offset, color.array );\n                    color.stride = sources[ id ].stride;\n                    break;\n\n                  case 'TEXCOORD':\n                    buildGeometryData( primitive, sources[ id ], input.offset, uv.array );\n                    uv.stride = sources[ id ].stride;\n                    break;\n\n                  case 'TEXCOORD1':\n                    buildGeometryData( primitive, sources[ id ], input.offset, uv2.array );\n                    uv.stride = sources[ id ].stride;\n                    break;\n\n                  default:\n                    console.warn( 'THREE.ColladaLoader: Semantic \"%s\" not handled in geometry build process.', key );\n\n                }\n\n              }\n              break;\n\n            case 'NORMAL':\n              buildGeometryData( primitive, sources[ input.id ], input.offset, normal.array );\n              normal.stride = sources[ input.id ].stride;\n              break;\n\n            case 'COLOR':\n              buildGeometryData( primitive, sources[ input.id ], input.offset, color.array );\n              color.stride = sources[ input.id ].stride;\n              break;\n\n            case 'TEXCOORD':\n              buildGeometryData( primitive, sources[ input.id ], input.offset, uv.array );\n              uv.stride = sources[ input.id ].stride;\n              break;\n\n            case 'TEXCOORD1':\n              buildGeometryData( primitive, sources[ input.id ], input.offset, uv2.array );\n              uv2.stride = sources[ input.id ].stride;\n              break;\n\n          }\n\n        }\n\n      }\n\n      // build geometry\n\n      if ( position.array.length > 0 ) geometry.addAttribute( 'position', new THREE.Float32BufferAttribute( position.array, position.stride ) );\n      if ( normal.array.length > 0 ) geometry.addAttribute( 'normal', new THREE.Float32BufferAttribute( normal.array, normal.stride ) );\n      if ( color.array.length > 0 ) geometry.addAttribute( 'color', new THREE.Float32BufferAttribute( color.array, color.stride ) );\n      if ( uv.array.length > 0 ) geometry.addAttribute( 'uv', new THREE.Float32BufferAttribute( uv.array, uv.stride ) );\n      if ( uv2.array.length > 0 ) geometry.addAttribute( 'uv2', new THREE.Float32BufferAttribute( uv2.array, uv2.stride ) );\n\n      if ( skinIndex.array.length > 0 ) geometry.addAttribute( 'skinIndex', new THREE.Float32BufferAttribute( skinIndex.array, skinIndex.stride ) );\n      if ( skinWeight.array.length > 0 ) geometry.addAttribute( 'skinWeight', new THREE.Float32BufferAttribute( skinWeight.array, skinWeight.stride ) );\n\n      build.data = geometry;\n      build.type = primitives[ 0 ].type;\n      build.materialKeys = materialKeys;\n\n      return build;\n\n    }\n\n    function buildGeometryData( primitive, source, offset, array ) {\n\n      var indices = primitive.p;\n      var stride = primitive.stride;\n      var vcount = primitive.vcount;\n\n      function pushVector( i ) {\n\n        var index = indices[ i + offset ] * sourceStride;\n        var length = index + sourceStride;\n\n        for ( ; index < length; index ++ ) {\n\n          array.push( sourceArray[ index ] );\n\n        }\n\n      }\n\n      var sourceArray = source.array;\n      var sourceStride = source.stride;\n\n      if ( primitive.vcount !== undefined ) {\n\n        var index = 0;\n\n        for ( var i = 0, l = vcount.length; i < l; i ++ ) {\n\n          var count = vcount[ i ];\n\n          if ( count === 4 ) {\n\n            var a = index + stride * 0;\n            var b = index + stride * 1;\n            var c = index + stride * 2;\n            var d = index + stride * 3;\n\n            pushVector( a ); pushVector( b ); pushVector( d );\n            pushVector( b ); pushVector( c ); pushVector( d );\n\n          } else if ( count === 3 ) {\n\n            var a = index + stride * 0;\n            var b = index + stride * 1;\n            var c = index + stride * 2;\n\n            pushVector( a ); pushVector( b ); pushVector( c );\n\n          } else if ( count > 4 ) {\n\n            for ( var k = 1, kl = ( count - 2 ); k <= kl; k ++ ) {\n\n              var a = index + stride * 0;\n              var b = index + stride * k;\n              var c = index + stride * ( k + 1 );\n\n              pushVector( a ); pushVector( b ); pushVector( c );\n\n            }\n\n          }\n\n          index += stride * count;\n\n        }\n\n      } else {\n\n        for ( var i = 0, l = indices.length; i < l; i += stride ) {\n\n          pushVector( i );\n\n        }\n\n      }\n\n    }\n\n    function getGeometry( id ) {\n\n      return getBuild( library.geometries[ id ], buildGeometry );\n\n    }\n\n    // kinematics\n\n    function parseKinematicsModel( xml ) {\n\n      var data = {\n        name: xml.getAttribute( 'name' ) || '',\n        joints: {},\n        links: []\n      };\n\n      for ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'technique_common':\n            parseKinematicsTechniqueCommon( child, data );\n            break;\n\n        }\n\n      }\n\n      library.kinematicsModels[ xml.getAttribute( 'id' ) ] = data;\n\n    }\n\n    function buildKinematicsModel( data ) {\n\n      if ( data.build !== undefined ) return data.build;\n\n      return data;\n\n    }\n\n    function getKinematicsModel( id ) {\n\n      return getBuild( library.kinematicsModels[ id ], buildKinematicsModel );\n\n    }\n\n    function parseKinematicsTechniqueCommon( xml, data ) {\n\n      for ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'joint':\n            data.joints[ child.getAttribute( 'sid' ) ] = parseKinematicsJoint( child );\n            break;\n\n          case 'link':\n            data.links.push( parseKinematicsLink( child ) );\n            break;\n\n        }\n\n      }\n\n    }\n\n    function parseKinematicsJoint( xml ) {\n\n      var data;\n\n      for ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'prismatic':\n          case 'revolute':\n            data = parseKinematicsJointParameter( child );\n            break;\n\n        }\n\n      }\n\n      return data;\n\n    }\n\n    function parseKinematicsJointParameter( xml, data ) {\n\n      var data = {\n        sid: xml.getAttribute( 'sid' ),\n        name: xml.getAttribute( 'name' ) || '',\n        axis: new THREE.Vector3(),\n        limits: {\n          min: 0,\n          max: 0\n        },\n        type: xml.nodeName,\n        static: false,\n        zeroPosition: 0,\n        middlePosition: 0\n      };\n\n      for ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'axis':\n            var array = parseFloats( child.textContent );\n            data.axis.fromArray( array );\n            break;\n          case 'limits':\n            var max = child.getElementsByTagName( 'max' )[ 0 ];\n            var min = child.getElementsByTagName( 'min' )[ 0 ];\n\n            data.limits.max = parseFloat( max.textContent );\n            data.limits.min = parseFloat( min.textContent );\n            break;\n\n        }\n\n      }\n\n      // if min is equal to or greater than max, consider the joint static\n\n      if ( data.limits.min >= data.limits.max ) {\n\n        data.static = true;\n\n      }\n\n      // calculate middle position\n\n      data.middlePosition = ( data.limits.min + data.limits.max ) / 2.0;\n\n      return data;\n\n    }\n\n    function parseKinematicsLink( xml ) {\n\n      var data = {\n        sid: xml.getAttribute( 'sid' ),\n        name: xml.getAttribute( 'name' ) || '',\n        attachments: [],\n        transforms: []\n      };\n\n      for ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'attachment_full':\n            data.attachments.push( parseKinematicsAttachment( child ) );\n            break;\n\n          case 'matrix':\n          case 'translate':\n          case 'rotate':\n            data.transforms.push( parseKinematicsTransform( child ) );\n            break;\n\n        }\n\n      }\n\n      return data;\n\n    }\n\n    function parseKinematicsAttachment( xml ) {\n\n      var data = {\n        joint: xml.getAttribute( 'joint' ).split( '/' ).pop(),\n        transforms: [],\n        links: []\n      };\n\n      for ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'link':\n            data.links.push( parseKinematicsLink( child ) );\n            break;\n\n          case 'matrix':\n          case 'translate':\n          case 'rotate':\n            data.transforms.push( parseKinematicsTransform( child ) );\n            break;\n\n        }\n\n      }\n\n      return data;\n\n    }\n\n    function parseKinematicsTransform( xml ) {\n\n      var data = {\n        type: xml.nodeName\n      };\n\n      var array = parseFloats( xml.textContent );\n\n      switch ( data.type ) {\n\n        case 'matrix':\n          data.obj = new THREE.Matrix4();\n          data.obj.fromArray( array ).transpose();\n          break;\n\n        case 'translate':\n          data.obj = new THREE.Vector3();\n          data.obj.fromArray( array );\n          break;\n\n        case 'rotate':\n          data.obj = new THREE.Vector3();\n          data.obj.fromArray( array );\n          data.angle = THREE.MathUtils.degToRad( array[ 3 ] );\n          break;\n\n      }\n\n      return data;\n\n    }\n\n    // physics\n\n    function parsePhysicsModel( xml ) {\n\n      var data = {\n        name: xml.getAttribute( 'name' ) || '',\n        rigidBodies: {}\n      };\n\n      for ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'rigid_body':\n            data.rigidBodies[ child.getAttribute( 'name' ) ] = {};\n            parsePhysicsRigidBody( child, data.rigidBodies[ child.getAttribute( 'name' ) ] );\n            break;\n\n        }\n\n      }\n\n      library.physicsModels[ xml.getAttribute( 'id' ) ] = data;\n\n    }\n\n    function parsePhysicsRigidBody( xml, data ) {\n\n      for ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'technique_common':\n            parsePhysicsTechniqueCommon( child, data );\n            break;\n\n        }\n\n      }\n\n    }\n\n    function parsePhysicsTechniqueCommon( xml, data ) {\n\n      for ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'inertia':\n            data.inertia = parseFloats( child.textContent );\n            break;\n\n          case 'mass':\n            data.mass = parseFloats( child.textContent )[ 0 ];\n            break;\n\n        }\n\n      }\n\n    }\n\n    // scene\n\n    function parseKinematicsScene( xml ) {\n\n      var data = {\n        bindJointAxis: []\n      };\n\n      for ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'bind_joint_axis':\n            data.bindJointAxis.push( parseKinematicsBindJointAxis( child ) );\n            break;\n\n        }\n\n      }\n\n      library.kinematicsScenes[ parseId( xml.getAttribute( 'url' ) ) ] = data;\n\n    }\n\n    function parseKinematicsBindJointAxis( xml ) {\n\n      var data = {\n        target: xml.getAttribute( 'target' ).split( '/' ).pop()\n      };\n\n      for ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'axis':\n            var param = child.getElementsByTagName( 'param' )[ 0 ];\n            data.axis = param.textContent;\n            var tmpJointIndex = data.axis.split( 'inst_' ).pop().split( 'axis' )[ 0 ];\n            data.jointIndex = tmpJointIndex.substr( 0, tmpJointIndex.length - 1 );\n            break;\n\n        }\n\n      }\n\n      return data;\n\n    }\n\n    function buildKinematicsScene( data ) {\n\n      if ( data.build !== undefined ) return data.build;\n\n      return data;\n\n    }\n\n    function getKinematicsScene( id ) {\n\n      return getBuild( library.kinematicsScenes[ id ], buildKinematicsScene );\n\n    }\n\n    function setupKinematics() {\n\n      var kinematicsModelId = Object.keys( library.kinematicsModels )[ 0 ];\n      var kinematicsSceneId = Object.keys( library.kinematicsScenes )[ 0 ];\n      var visualSceneId = Object.keys( library.visualScenes )[ 0 ];\n\n      if ( kinematicsModelId === undefined || kinematicsSceneId === undefined ) return;\n\n      var kinematicsModel = getKinematicsModel( kinematicsModelId );\n      var kinematicsScene = getKinematicsScene( kinematicsSceneId );\n      var visualScene = getVisualScene( visualSceneId );\n\n      var bindJointAxis = kinematicsScene.bindJointAxis;\n      var jointMap = {};\n\n      for ( var i = 0, l = bindJointAxis.length; i < l; i ++ ) {\n\n        var axis = bindJointAxis[ i ];\n\n        // the result of the following query is an element of type 'translate', 'rotate','scale' or 'matrix'\n\n        var targetElement = collada.querySelector( '[sid=\"' + axis.target + '\"]' );\n\n        if ( targetElement ) {\n\n          // get the parent of the transfrom element\n\n          var parentVisualElement = targetElement.parentElement;\n\n          // connect the joint of the kinematics model with the element in the visual scene\n\n          connect( axis.jointIndex, parentVisualElement );\n\n        }\n\n      }\n\n      function connect( jointIndex, visualElement ) {\n\n        var visualElementName = visualElement.getAttribute( 'name' );\n        var joint = kinematicsModel.joints[ jointIndex ];\n\n        visualScene.traverse( function ( object ) {\n\n          if ( object.name === visualElementName ) {\n\n            jointMap[ jointIndex ] = {\n              object: object,\n              transforms: buildTransformList( visualElement ),\n              joint: joint,\n              position: joint.zeroPosition\n            };\n\n          }\n\n        } );\n\n      }\n\n      var m0 = new THREE.Matrix4();\n\n      kinematics = {\n\n        joints: kinematicsModel && kinematicsModel.joints,\n\n        getJointValue: function ( jointIndex ) {\n\n          var jointData = jointMap[ jointIndex ];\n\n          if ( jointData ) {\n\n            return jointData.position;\n\n          } else {\n\n            console.warn( 'THREE.ColladaLoader: Joint ' + jointIndex + ' doesn\\'t exist.' );\n\n          }\n\n        },\n\n        setJointValue: function ( jointIndex, value ) {\n\n          var jointData = jointMap[ jointIndex ];\n\n          if ( jointData ) {\n\n            var joint = jointData.joint;\n\n            if ( value > joint.limits.max || value < joint.limits.min ) {\n\n              console.warn( 'THREE.ColladaLoader: Joint ' + jointIndex + ' value ' + value + ' outside of limits (min: ' + joint.limits.min + ', max: ' + joint.limits.max + ').' );\n\n            } else if ( joint.static ) {\n\n              console.warn( 'THREE.ColladaLoader: Joint ' + jointIndex + ' is static.' );\n\n            } else {\n\n              var object = jointData.object;\n              var axis = joint.axis;\n              var transforms = jointData.transforms;\n\n              matrix.identity();\n\n              // each update, we have to apply all transforms in the correct order\n\n              for ( var i = 0; i < transforms.length; i ++ ) {\n\n                var transform = transforms[ i ];\n\n                // if there is a connection of the transform node with a joint, apply the joint value\n\n                if ( transform.sid && transform.sid.indexOf( jointIndex ) !== - 1 ) {\n\n                  switch ( joint.type ) {\n\n                    case 'revolute':\n                      matrix.multiply( m0.makeRotationAxis( axis, THREE.MathUtils.degToRad( value ) ) );\n                      break;\n\n                    case 'prismatic':\n                      matrix.multiply( m0.makeTranslation( axis.x * value, axis.y * value, axis.z * value ) );\n                      break;\n\n                    default:\n                      console.warn( 'THREE.ColladaLoader: Unknown joint type: ' + joint.type );\n                      break;\n\n                  }\n\n                } else {\n\n                  switch ( transform.type ) {\n\n                    case 'matrix':\n                      matrix.multiply( transform.obj );\n                      break;\n\n                    case 'translate':\n                      matrix.multiply( m0.makeTranslation( transform.obj.x, transform.obj.y, transform.obj.z ) );\n                      break;\n\n                    case 'scale':\n                      matrix.scale( transform.obj );\n                      break;\n\n                    case 'rotate':\n                      matrix.multiply( m0.makeRotationAxis( transform.obj, transform.angle ) );\n                      break;\n\n                  }\n\n                }\n\n              }\n\n              object.matrix.copy( matrix );\n              object.matrix.decompose( object.position, object.quaternion, object.scale );\n\n              jointMap[ jointIndex ].position = value;\n\n            }\n\n          } else {\n\n            console.log( 'THREE.ColladaLoader: ' + jointIndex + ' does not exist.' );\n\n          }\n\n        }\n\n      };\n\n    }\n\n    function buildTransformList( node ) {\n\n      var transforms = [];\n\n      var xml = collada.querySelector( '[id=\"' + node.id + '\"]' );\n\n      for ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'matrix':\n            var array = parseFloats( child.textContent );\n            var matrix = new THREE.Matrix4().fromArray( array ).transpose();\n            transforms.push( {\n              sid: child.getAttribute( 'sid' ),\n              type: child.nodeName,\n              obj: matrix\n            } );\n            break;\n\n          case 'translate':\n          case 'scale':\n            var array = parseFloats( child.textContent );\n            var vector = new THREE.Vector3().fromArray( array );\n            transforms.push( {\n              sid: child.getAttribute( 'sid' ),\n              type: child.nodeName,\n              obj: vector\n            } );\n            break;\n\n          case 'rotate':\n            var array = parseFloats( child.textContent );\n            var vector = new THREE.Vector3().fromArray( array );\n            var angle = THREE.MathUtils.degToRad( array[ 3 ] );\n            transforms.push( {\n              sid: child.getAttribute( 'sid' ),\n              type: child.nodeName,\n              obj: vector,\n              angle: angle\n            } );\n            break;\n\n        }\n\n      }\n\n      return transforms;\n\n    }\n\n    // nodes\n\n    function prepareNodes( xml ) {\n\n      var elements = xml.getElementsByTagName( 'node' );\n\n      // ensure all node elements have id attributes\n\n      for ( var i = 0; i < elements.length; i ++ ) {\n\n        var element = elements[ i ];\n\n        if ( element.hasAttribute( 'id' ) === false ) {\n\n          element.setAttribute( 'id', generateId() );\n\n        }\n\n      }\n\n    }\n\n    var matrix = new THREE.Matrix4();\n    var vector = new THREE.Vector3();\n\n    function parseNode( xml ) {\n\n      var data = {\n        name: xml.getAttribute( 'name' ) || '',\n        type: xml.getAttribute( 'type' ),\n        id: xml.getAttribute( 'id' ),\n        sid: xml.getAttribute( 'sid' ),\n        matrix: new THREE.Matrix4(),\n        nodes: [],\n        instanceCameras: [],\n        instanceControllers: [],\n        instanceLights: [],\n        instanceGeometries: [],\n        instanceNodes: [],\n        transforms: {}\n      };\n\n      for ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'node':\n            data.nodes.push( child.getAttribute( 'id' ) );\n            parseNode( child );\n            break;\n\n          case 'instance_camera':\n            data.instanceCameras.push( parseId( child.getAttribute( 'url' ) ) );\n            break;\n\n          case 'instance_controller':\n            data.instanceControllers.push( parseNodeInstance( child ) );\n            break;\n\n          case 'instance_light':\n            data.instanceLights.push( parseId( child.getAttribute( 'url' ) ) );\n            break;\n\n          case 'instance_geometry':\n            data.instanceGeometries.push( parseNodeInstance( child ) );\n            break;\n\n          case 'instance_node':\n            data.instanceNodes.push( parseId( child.getAttribute( 'url' ) ) );\n            break;\n\n          case 'matrix':\n            var array = parseFloats( child.textContent );\n            data.matrix.multiply( matrix.fromArray( array ).transpose() );\n            data.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\n            break;\n\n          case 'translate':\n            var array = parseFloats( child.textContent );\n            vector.fromArray( array );\n            data.matrix.multiply( matrix.makeTranslation( vector.x, vector.y, vector.z ) );\n            data.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\n            break;\n\n          case 'rotate':\n            var array = parseFloats( child.textContent );\n            var angle = THREE.MathUtils.degToRad( array[ 3 ] );\n            data.matrix.multiply( matrix.makeRotationAxis( vector.fromArray( array ), angle ) );\n            data.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\n            break;\n\n          case 'scale':\n            var array = parseFloats( child.textContent );\n            data.matrix.scale( vector.fromArray( array ) );\n            data.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\n            break;\n\n          case 'extra':\n            break;\n\n          default:\n            console.log( child );\n\n        }\n\n      }\n\n      if ( hasNode( data.id ) ) {\n\n        console.warn( 'THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.', data.id );\n\n      } else {\n\n        library.nodes[ data.id ] = data;\n\n      }\n\n      return data;\n\n    }\n\n    function parseNodeInstance( xml ) {\n\n      var data = {\n        id: parseId( xml.getAttribute( 'url' ) ),\n        materials: {},\n        skeletons: []\n      };\n\n      for ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        switch ( child.nodeName ) {\n\n          case 'bind_material':\n            var instances = child.getElementsByTagName( 'instance_material' );\n\n            for ( var j = 0; j < instances.length; j ++ ) {\n\n              var instance = instances[ j ];\n              var symbol = instance.getAttribute( 'symbol' );\n              var target = instance.getAttribute( 'target' );\n\n              data.materials[ symbol ] = parseId( target );\n\n            }\n\n            break;\n\n          case 'skeleton':\n            data.skeletons.push( parseId( child.textContent ) );\n            break;\n\n          default:\n            break;\n\n        }\n\n      }\n\n      return data;\n\n    }\n\n    function buildSkeleton( skeletons, joints ) {\n\n      var boneData = [];\n      var sortedBoneData = [];\n\n      var i, j, data;\n\n      // a skeleton can have multiple root bones. collada expresses this\n      // situtation with multiple \"skeleton\" tags per controller instance\n\n      for ( i = 0; i < skeletons.length; i ++ ) {\n\n        var skeleton = skeletons[ i ];\n\n        var root;\n\n        if ( hasNode( skeleton ) ) {\n\n          root = getNode( skeleton );\n          buildBoneHierarchy( root, joints, boneData );\n\n        } else if ( hasVisualScene( skeleton ) ) {\n\n          // handle case where the skeleton refers to the visual scene (#13335)\n\n          var visualScene = library.visualScenes[ skeleton ];\n          var children = visualScene.children;\n\n          for ( var j = 0; j < children.length; j ++ ) {\n\n            var child = children[ j ];\n\n            if ( child.type === 'JOINT' ) {\n\n              var root = getNode( child.id );\n              buildBoneHierarchy( root, joints, boneData );\n\n            }\n\n          }\n\n        } else {\n\n          console.error( 'THREE.ColladaLoader: Unable to find root bone of skeleton with ID:', skeleton );\n\n        }\n\n      }\n\n      // sort bone data (the order is defined in the corresponding controller)\n\n      for ( i = 0; i < joints.length; i ++ ) {\n\n        for ( j = 0; j < boneData.length; j ++ ) {\n\n          data = boneData[ j ];\n\n          if ( data.bone.name === joints[ i ].name ) {\n\n            sortedBoneData[ i ] = data;\n            data.processed = true;\n            break;\n\n          }\n\n        }\n\n      }\n\n      // add unprocessed bone data at the end of the list\n\n      for ( i = 0; i < boneData.length; i ++ ) {\n\n        data = boneData[ i ];\n\n        if ( data.processed === false ) {\n\n          sortedBoneData.push( data );\n          data.processed = true;\n\n        }\n\n      }\n\n      // setup arrays for skeleton creation\n\n      var bones = [];\n      var boneInverses = [];\n\n      for ( i = 0; i < sortedBoneData.length; i ++ ) {\n\n        data = sortedBoneData[ i ];\n\n        bones.push( data.bone );\n        boneInverses.push( data.boneInverse );\n\n      }\n\n      return new THREE.Skeleton( bones, boneInverses );\n\n    }\n\n    function buildBoneHierarchy( root, joints, boneData ) {\n\n      // setup bone data from visual scene\n\n      root.traverse( function ( object ) {\n\n        if ( object.isBone === true ) {\n\n          var boneInverse;\n\n          // retrieve the boneInverse from the controller data\n\n          for ( var i = 0; i < joints.length; i ++ ) {\n\n            var joint = joints[ i ];\n\n            if ( joint.name === object.name ) {\n\n              boneInverse = joint.boneInverse;\n              break;\n\n            }\n\n          }\n\n          if ( boneInverse === undefined ) {\n\n            // Unfortunately, there can be joints in the visual scene that are not part of the\n            // corresponding controller. In this case, we have to create a dummy boneInverse matrix\n            // for the respective bone. This bone won't affect any vertices, because there are no skin indices\n            // and weights defined for it. But we still have to add the bone to the sorted bone list in order to\n            // ensure a correct animation of the model.\n\n            boneInverse = new THREE.Matrix4();\n\n          }\n\n          boneData.push( { bone: object, boneInverse: boneInverse, processed: false } );\n\n        }\n\n      } );\n\n    }\n\n    function buildNode( data ) {\n\n      var objects = [];\n\n      var matrix = data.matrix;\n      var nodes = data.nodes;\n      var type = data.type;\n      var instanceCameras = data.instanceCameras;\n      var instanceControllers = data.instanceControllers;\n      var instanceLights = data.instanceLights;\n      var instanceGeometries = data.instanceGeometries;\n      var instanceNodes = data.instanceNodes;\n\n      // nodes\n\n      for ( var i = 0, l = nodes.length; i < l; i ++ ) {\n\n        objects.push( getNode( nodes[ i ] ) );\n\n      }\n\n      // instance cameras\n\n      for ( var i = 0, l = instanceCameras.length; i < l; i ++ ) {\n\n        var instanceCamera = getCamera( instanceCameras[ i ] );\n\n        if ( instanceCamera !== null ) {\n\n          objects.push( instanceCamera.clone() );\n\n        }\n\n      }\n\n      // instance controllers\n\n      for ( var i = 0, l = instanceControllers.length; i < l; i ++ ) {\n\n        var instance = instanceControllers[ i ];\n        var controller = getController( instance.id );\n        var geometries = getGeometry( controller.id );\n        var newObjects = buildObjects( geometries, instance.materials );\n\n        var skeletons = instance.skeletons;\n        var joints = controller.skin.joints;\n\n        var skeleton = buildSkeleton( skeletons, joints );\n\n        for ( var j = 0, jl = newObjects.length; j < jl; j ++ ) {\n\n          var object = newObjects[ j ];\n\n          if ( object.isSkinnedMesh ) {\n\n            object.bind( skeleton, controller.skin.bindMatrix );\n            object.normalizeSkinWeights();\n\n          }\n\n          objects.push( object );\n\n        }\n\n      }\n\n      // instance lights\n\n      for ( var i = 0, l = instanceLights.length; i < l; i ++ ) {\n\n        var instanceLight = getLight( instanceLights[ i ] );\n\n        if ( instanceLight !== null ) {\n\n          objects.push( instanceLight.clone() );\n\n        }\n\n      }\n\n      // instance geometries\n\n      for ( var i = 0, l = instanceGeometries.length; i < l; i ++ ) {\n\n        var instance = instanceGeometries[ i ];\n\n        // a single geometry instance in collada can lead to multiple object3Ds.\n        // this is the case when primitives are combined like triangles and lines\n\n        var geometries = getGeometry( instance.id );\n        var newObjects = buildObjects( geometries, instance.materials );\n\n        for ( var j = 0, jl = newObjects.length; j < jl; j ++ ) {\n\n          objects.push( newObjects[ j ] );\n\n        }\n\n      }\n\n      // instance nodes\n\n      for ( var i = 0, l = instanceNodes.length; i < l; i ++ ) {\n\n        objects.push( getNode( instanceNodes[ i ] ).clone() );\n\n      }\n\n      var object;\n\n      if ( nodes.length === 0 && objects.length === 1 ) {\n\n        object = objects[ 0 ];\n\n      } else {\n\n        object = ( type === 'JOINT' ) ? new THREE.Bone() : new THREE.Group();\n\n        for ( var i = 0; i < objects.length; i ++ ) {\n\n          object.add( objects[ i ] );\n\n        }\n\n      }\n\n      if ( object.name === '' ) {\n\n        object.name = ( type === 'JOINT' ) ? data.sid : data.name;\n\n      }\n\n      object.matrix.copy( matrix );\n      object.matrix.decompose( object.position, object.quaternion, object.scale );\n\n      return object;\n\n    }\n\n    var fallbackMaterial = new THREE.MeshBasicMaterial( { color: 0xff00ff } );\n\n    function resolveMaterialBinding( keys, instanceMaterials ) {\n\n      var materials = [];\n\n      for ( var i = 0, l = keys.length; i < l; i ++ ) {\n\n        var id = instanceMaterials[ keys[ i ] ];\n\n        if ( id === undefined ) {\n\n          console.warn( 'THREE.ColladaLoader: Material with key %s not found. Apply fallback material.', keys[ i ] );\n          materials.push( fallbackMaterial );\n\n        } else {\n\n          materials.push( getMaterial( id ) );\n\n        }\n\n      }\n\n      return materials;\n\n    }\n\n    function buildObjects( geometries, instanceMaterials ) {\n\n      var objects = [];\n\n      for ( var type in geometries ) {\n\n        var geometry = geometries[ type ];\n\n        var materials = resolveMaterialBinding( geometry.materialKeys, instanceMaterials );\n\n        // handle case if no materials are defined\n\n        if ( materials.length === 0 ) {\n\n          if ( type === 'lines' || type === 'linestrips' ) {\n\n            materials.push( new THREE.LineBasicMaterial() );\n\n          } else {\n\n            materials.push( new THREE.MeshPhongMaterial() );\n\n          }\n\n        }\n\n        // regard skinning\n\n        var skinning = ( geometry.data.attributes.skinIndex !== undefined );\n\n        if ( skinning ) {\n\n          for ( var i = 0, l = materials.length; i < l; i ++ ) {\n\n            materials[ i ].skinning = true;\n\n          }\n\n        }\n\n        // choose between a single or multi materials (material array)\n\n        var material = ( materials.length === 1 ) ? materials[ 0 ] : materials;\n\n        // now create a specific 3D object\n\n        var object;\n\n        switch ( type ) {\n\n          case 'lines':\n            object = new THREE.LineSegments( geometry.data, material );\n            break;\n\n          case 'linestrips':\n            object = new THREE.Line( geometry.data, material );\n            break;\n\n          case 'triangles':\n          case 'polylist':\n            if ( skinning ) {\n\n              object = new THREE.SkinnedMesh( geometry.data, material );\n\n            } else {\n\n              object = new THREE.Mesh( geometry.data, material );\n\n            }\n            break;\n\n        }\n\n        objects.push( object );\n\n      }\n\n      return objects;\n\n    }\n\n    function hasNode( id ) {\n\n      return library.nodes[ id ] !== undefined;\n\n    }\n\n    function getNode( id ) {\n\n      return getBuild( library.nodes[ id ], buildNode );\n\n    }\n\n    // visual scenes\n\n    function parseVisualScene( xml ) {\n\n      var data = {\n        name: xml.getAttribute( 'name' ),\n        children: []\n      };\n\n      prepareNodes( xml );\n\n      var elements = getElementsByTagName( xml, 'node' );\n\n      for ( var i = 0; i < elements.length; i ++ ) {\n\n        data.children.push( parseNode( elements[ i ] ) );\n\n      }\n\n      library.visualScenes[ xml.getAttribute( 'id' ) ] = data;\n\n    }\n\n    function buildVisualScene( data ) {\n\n      var group = new THREE.Group();\n      group.name = data.name;\n\n      var children = data.children;\n\n      for ( var i = 0; i < children.length; i ++ ) {\n\n        var child = children[ i ];\n\n        group.add( getNode( child.id ) );\n\n      }\n\n      return group;\n\n    }\n\n    function hasVisualScene( id ) {\n\n      return library.visualScenes[ id ] !== undefined;\n\n    }\n\n    function getVisualScene( id ) {\n\n      return getBuild( library.visualScenes[ id ], buildVisualScene );\n\n    }\n\n    // scenes\n\n    function parseScene( xml ) {\n\n      var instance = getElementsByTagName( xml, 'instance_visual_scene' )[ 0 ];\n      return getVisualScene( parseId( instance.getAttribute( 'url' ) ) );\n\n    }\n\n    function setupAnimations() {\n\n      var clips = library.clips;\n\n      if ( isEmpty( clips ) === true ) {\n\n        if ( isEmpty( library.animations ) === false ) {\n\n          // if there are animations but no clips, we create a default clip for playback\n\n          var tracks = [];\n\n          for ( var id in library.animations ) {\n\n            var animationTracks = getAnimation( id );\n\n            for ( var i = 0, l = animationTracks.length; i < l; i ++ ) {\n\n              tracks.push( animationTracks[ i ] );\n\n            }\n\n          }\n\n          animations.push( new THREE.AnimationClip( 'default', - 1, tracks ) );\n\n        }\n\n      } else {\n\n        for ( var id in clips ) {\n\n          animations.push( getAnimationClip( id ) );\n\n        }\n\n      }\n\n    }\n\n    if ( text.length === 0 ) {\n\n      return { scene: new THREE.Scene() };\n\n    }\n\n    var xml = new DOMParser().parseFromString( text, 'application/xml' );\n\n    var collada = getElementsByTagName( xml, 'COLLADA' )[ 0 ];\n\n    // metadata\n\n    var version = collada.getAttribute( 'version' );\n    console.log( 'THREE.ColladaLoader: File version', version );\n\n    var asset = parseAsset( getElementsByTagName( collada, 'asset' )[ 0 ] );\n    var textureLoader = new THREE.TextureLoader( this.manager );\n    textureLoader.setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );\n\n    var tgaLoader;\n\n    if ( THREE.TGALoader ) {\n\n      tgaLoader = new THREE.TGALoader( this.manager );\n      tgaLoader.setPath( this.resourcePath || path );\n\n    }\n\n    //\n\n    var animations = [];\n    var kinematics = {};\n    var count = 0;\n\n    //\n\n    var library = {\n      animations: {},\n      clips: {},\n      controllers: {},\n      images: {},\n      effects: {},\n      materials: {},\n      cameras: {},\n      lights: {},\n      geometries: {},\n      nodes: {},\n      visualScenes: {},\n      kinematicsModels: {},\n      physicsModels: {},\n      kinematicsScenes: {}\n    };\n\n    parseLibrary( collada, 'library_animations', 'animation', parseAnimation );\n    parseLibrary( collada, 'library_animation_clips', 'animation_clip', parseAnimationClip );\n    parseLibrary( collada, 'library_controllers', 'controller', parseController );\n    parseLibrary( collada, 'library_images', 'image', parseImage );\n    parseLibrary( collada, 'library_effects', 'effect', parseEffect );\n    parseLibrary( collada, 'library_materials', 'material', parseMaterial );\n    parseLibrary( collada, 'library_cameras', 'camera', parseCamera );\n    parseLibrary( collada, 'library_lights', 'light', parseLight );\n    parseLibrary( collada, 'library_geometries', 'geometry', parseGeometry );\n    parseLibrary( collada, 'library_nodes', 'node', parseNode );\n    parseLibrary( collada, 'library_visual_scenes', 'visual_scene', parseVisualScene );\n    parseLibrary( collada, 'library_kinematics_models', 'kinematics_model', parseKinematicsModel );\n    parseLibrary( collada, 'library_physics_models', 'physics_model', parsePhysicsModel );\n    parseLibrary( collada, 'scene', 'instance_kinematics_scene', parseKinematicsScene );\n\n    buildLibrary( library.animations, buildAnimation );\n    buildLibrary( library.clips, buildAnimationClip );\n    buildLibrary( library.controllers, buildController );\n    buildLibrary( library.images, buildImage );\n    buildLibrary( library.effects, buildEffect );\n    buildLibrary( library.materials, buildMaterial );\n    buildLibrary( library.cameras, buildCamera );\n    buildLibrary( library.lights, buildLight );\n    buildLibrary( library.geometries, buildGeometry );\n    buildLibrary( library.visualScenes, buildVisualScene );\n\n    setupAnimations();\n    setupKinematics();\n\n    var scene = parseScene( getElementsByTagName( collada, 'scene' )[ 0 ] );\n\n    if ( asset.upAxis === 'Z_UP' ) {\n\n      scene.quaternion.setFromEuler( new THREE.Euler( - Math.PI / 2, 0, 0 ) );\n\n    }\n\n    scene.scale.multiplyScalar( asset.unit );\n\n    return {\n      animations: animations,\n      kinematics: kinematics,\n      library: library,\n      scene: scene\n    };\n\n  }\n\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}