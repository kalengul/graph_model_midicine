{"ast":null,"code":"import adder from \"./adder.js\";\nimport { areaStream, areaRingSum } from \"./area.js\";\nimport { cartesian, cartesianCross, cartesianNormalizeInPlace, spherical } from \"./cartesian.js\";\nimport { abs, degrees, epsilon, radians } from \"./math.js\";\nimport stream from \"./stream.js\";\nvar lambda0,\n  phi0,\n  lambda1,\n  phi1,\n  // bounds\n  lambda2,\n  // previous lambda-coordinate\n  lambda00,\n  phi00,\n  // first point\n  p0,\n  // previous 3D point\n  deltaSum = adder(),\n  ranges,\n  range;\nvar boundsStream = {\n  point: boundsPoint,\n  lineStart: boundsLineStart,\n  lineEnd: boundsLineEnd,\n  polygonStart: function () {\n    boundsStream.point = boundsRingPoint;\n    boundsStream.lineStart = boundsRingStart;\n    boundsStream.lineEnd = boundsRingEnd;\n    deltaSum.reset();\n    areaStream.polygonStart();\n  },\n  polygonEnd: function () {\n    areaStream.polygonEnd();\n    boundsStream.point = boundsPoint;\n    boundsStream.lineStart = boundsLineStart;\n    boundsStream.lineEnd = boundsLineEnd;\n    if (areaRingSum < 0) lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);else if (deltaSum > epsilon) phi1 = 90;else if (deltaSum < -epsilon) phi0 = -90;\n    range[0] = lambda0, range[1] = lambda1;\n  },\n  sphere: function () {\n    lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);\n  }\n};\nfunction boundsPoint(lambda, phi) {\n  ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);\n  if (phi < phi0) phi0 = phi;\n  if (phi > phi1) phi1 = phi;\n}\nfunction linePoint(lambda, phi) {\n  var p = cartesian([lambda * radians, phi * radians]);\n  if (p0) {\n    var normal = cartesianCross(p0, p),\n      equatorial = [normal[1], -normal[0], 0],\n      inflection = cartesianCross(equatorial, normal);\n    cartesianNormalizeInPlace(inflection);\n    inflection = spherical(inflection);\n    var delta = lambda - lambda2,\n      sign = delta > 0 ? 1 : -1,\n      lambdai = inflection[0] * degrees * sign,\n      phii,\n      antimeridian = abs(delta) > 180;\n    if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {\n      phii = inflection[1] * degrees;\n      if (phii > phi1) phi1 = phii;\n    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {\n      phii = -inflection[1] * degrees;\n      if (phii < phi0) phi0 = phii;\n    } else {\n      if (phi < phi0) phi0 = phi;\n      if (phi > phi1) phi1 = phi;\n    }\n    if (antimeridian) {\n      if (lambda < lambda2) {\n        if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;\n      } else {\n        if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;\n      }\n    } else {\n      if (lambda1 >= lambda0) {\n        if (lambda < lambda0) lambda0 = lambda;\n        if (lambda > lambda1) lambda1 = lambda;\n      } else {\n        if (lambda > lambda2) {\n          if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;\n        } else {\n          if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;\n        }\n      }\n    }\n  } else {\n    ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);\n  }\n  if (phi < phi0) phi0 = phi;\n  if (phi > phi1) phi1 = phi;\n  p0 = p, lambda2 = lambda;\n}\nfunction boundsLineStart() {\n  boundsStream.point = linePoint;\n}\nfunction boundsLineEnd() {\n  range[0] = lambda0, range[1] = lambda1;\n  boundsStream.point = boundsPoint;\n  p0 = null;\n}\nfunction boundsRingPoint(lambda, phi) {\n  if (p0) {\n    var delta = lambda - lambda2;\n    deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);\n  } else {\n    lambda00 = lambda, phi00 = phi;\n  }\n  areaStream.point(lambda, phi);\n  linePoint(lambda, phi);\n}\nfunction boundsRingStart() {\n  areaStream.lineStart();\n}\nfunction boundsRingEnd() {\n  boundsRingPoint(lambda00, phi00);\n  areaStream.lineEnd();\n  if (abs(deltaSum) > epsilon) lambda0 = -(lambda1 = 180);\n  range[0] = lambda0, range[1] = lambda1;\n  p0 = null;\n}\n\n// Finds the left-right distance between two longitudes.\n// This is almost the same as (lambda1 - lambda0 + 360°) % 360°, except that we want\n// the distance between ±180° to be 360°.\nfunction angle(lambda0, lambda1) {\n  return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;\n}\nfunction rangeCompare(a, b) {\n  return a[0] - b[0];\n}\nfunction rangeContains(range, x) {\n  return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;\n}\nexport default function (feature) {\n  var i, n, a, b, merged, deltaMax, delta;\n  phi1 = lambda1 = -(lambda0 = phi0 = Infinity);\n  ranges = [];\n  stream(feature, boundsStream);\n\n  // First, sort ranges by their minimum longitudes.\n  if (n = ranges.length) {\n    ranges.sort(rangeCompare);\n\n    // Then, merge any ranges that overlap.\n    for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {\n      b = ranges[i];\n      if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {\n        if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];\n        if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];\n      } else {\n        merged.push(a = b);\n      }\n    }\n\n    // Finally, find the largest gap between the merged ranges.\n    // The final bounding box will be the inverse of this gap.\n    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {\n      b = merged[i];\n      if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0 = b[0], lambda1 = a[1];\n    }\n  }\n  ranges = range = null;\n  return lambda0 === Infinity || phi0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[lambda0, phi0], [lambda1, phi1]];\n}","map":{"version":3,"names":["adder","areaStream","areaRingSum","cartesian","cartesianCross","cartesianNormalizeInPlace","spherical","abs","degrees","epsilon","radians","stream","lambda0","phi0","lambda1","phi1","lambda2","lambda00","phi00","p0","deltaSum","ranges","range","boundsStream","point","boundsPoint","lineStart","boundsLineStart","lineEnd","boundsLineEnd","polygonStart","boundsRingPoint","boundsRingStart","boundsRingEnd","reset","polygonEnd","sphere","lambda","phi","push","linePoint","p","normal","equatorial","inflection","delta","sign","lambdai","phii","antimeridian","angle","add","rangeCompare","a","b","rangeContains","x","feature","i","n","merged","deltaMax","Infinity","length","sort","NaN"],"sources":["C:/UsersFolders/Polina/РЭУ/Graph/graph_model_midicine/view/node_modules/d3-geo/src/bounds.js"],"sourcesContent":["import adder from \"./adder.js\";\nimport {areaStream, areaRingSum} from \"./area.js\";\nimport {cartesian, cartesianCross, cartesianNormalizeInPlace, spherical} from \"./cartesian.js\";\nimport {abs, degrees, epsilon, radians} from \"./math.js\";\nimport stream from \"./stream.js\";\n\nvar lambda0, phi0, lambda1, phi1, // bounds\n    lambda2, // previous lambda-coordinate\n    lambda00, phi00, // first point\n    p0, // previous 3D point\n    deltaSum = adder(),\n    ranges,\n    range;\n\nvar boundsStream = {\n  point: boundsPoint,\n  lineStart: boundsLineStart,\n  lineEnd: boundsLineEnd,\n  polygonStart: function() {\n    boundsStream.point = boundsRingPoint;\n    boundsStream.lineStart = boundsRingStart;\n    boundsStream.lineEnd = boundsRingEnd;\n    deltaSum.reset();\n    areaStream.polygonStart();\n  },\n  polygonEnd: function() {\n    areaStream.polygonEnd();\n    boundsStream.point = boundsPoint;\n    boundsStream.lineStart = boundsLineStart;\n    boundsStream.lineEnd = boundsLineEnd;\n    if (areaRingSum < 0) lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);\n    else if (deltaSum > epsilon) phi1 = 90;\n    else if (deltaSum < -epsilon) phi0 = -90;\n    range[0] = lambda0, range[1] = lambda1;\n  },\n  sphere: function() {\n    lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);\n  }\n};\n\nfunction boundsPoint(lambda, phi) {\n  ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);\n  if (phi < phi0) phi0 = phi;\n  if (phi > phi1) phi1 = phi;\n}\n\nfunction linePoint(lambda, phi) {\n  var p = cartesian([lambda * radians, phi * radians]);\n  if (p0) {\n    var normal = cartesianCross(p0, p),\n        equatorial = [normal[1], -normal[0], 0],\n        inflection = cartesianCross(equatorial, normal);\n    cartesianNormalizeInPlace(inflection);\n    inflection = spherical(inflection);\n    var delta = lambda - lambda2,\n        sign = delta > 0 ? 1 : -1,\n        lambdai = inflection[0] * degrees * sign,\n        phii,\n        antimeridian = abs(delta) > 180;\n    if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {\n      phii = inflection[1] * degrees;\n      if (phii > phi1) phi1 = phii;\n    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {\n      phii = -inflection[1] * degrees;\n      if (phii < phi0) phi0 = phii;\n    } else {\n      if (phi < phi0) phi0 = phi;\n      if (phi > phi1) phi1 = phi;\n    }\n    if (antimeridian) {\n      if (lambda < lambda2) {\n        if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;\n      } else {\n        if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;\n      }\n    } else {\n      if (lambda1 >= lambda0) {\n        if (lambda < lambda0) lambda0 = lambda;\n        if (lambda > lambda1) lambda1 = lambda;\n      } else {\n        if (lambda > lambda2) {\n          if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;\n        } else {\n          if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;\n        }\n      }\n    }\n  } else {\n    ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);\n  }\n  if (phi < phi0) phi0 = phi;\n  if (phi > phi1) phi1 = phi;\n  p0 = p, lambda2 = lambda;\n}\n\nfunction boundsLineStart() {\n  boundsStream.point = linePoint;\n}\n\nfunction boundsLineEnd() {\n  range[0] = lambda0, range[1] = lambda1;\n  boundsStream.point = boundsPoint;\n  p0 = null;\n}\n\nfunction boundsRingPoint(lambda, phi) {\n  if (p0) {\n    var delta = lambda - lambda2;\n    deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);\n  } else {\n    lambda00 = lambda, phi00 = phi;\n  }\n  areaStream.point(lambda, phi);\n  linePoint(lambda, phi);\n}\n\nfunction boundsRingStart() {\n  areaStream.lineStart();\n}\n\nfunction boundsRingEnd() {\n  boundsRingPoint(lambda00, phi00);\n  areaStream.lineEnd();\n  if (abs(deltaSum) > epsilon) lambda0 = -(lambda1 = 180);\n  range[0] = lambda0, range[1] = lambda1;\n  p0 = null;\n}\n\n// Finds the left-right distance between two longitudes.\n// This is almost the same as (lambda1 - lambda0 + 360°) % 360°, except that we want\n// the distance between ±180° to be 360°.\nfunction angle(lambda0, lambda1) {\n  return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;\n}\n\nfunction rangeCompare(a, b) {\n  return a[0] - b[0];\n}\n\nfunction rangeContains(range, x) {\n  return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;\n}\n\nexport default function(feature) {\n  var i, n, a, b, merged, deltaMax, delta;\n\n  phi1 = lambda1 = -(lambda0 = phi0 = Infinity);\n  ranges = [];\n  stream(feature, boundsStream);\n\n  // First, sort ranges by their minimum longitudes.\n  if (n = ranges.length) {\n    ranges.sort(rangeCompare);\n\n    // Then, merge any ranges that overlap.\n    for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {\n      b = ranges[i];\n      if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {\n        if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];\n        if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];\n      } else {\n        merged.push(a = b);\n      }\n    }\n\n    // Finally, find the largest gap between the merged ranges.\n    // The final bounding box will be the inverse of this gap.\n    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {\n      b = merged[i];\n      if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0 = b[0], lambda1 = a[1];\n    }\n  }\n\n  ranges = range = null;\n\n  return lambda0 === Infinity || phi0 === Infinity\n      ? [[NaN, NaN], [NaN, NaN]]\n      : [[lambda0, phi0], [lambda1, phi1]];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}